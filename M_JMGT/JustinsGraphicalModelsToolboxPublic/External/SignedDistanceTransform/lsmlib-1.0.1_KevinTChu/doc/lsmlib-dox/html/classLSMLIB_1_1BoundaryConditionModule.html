<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LSMLIB:  TemplateLSMLIB::BoundaryConditionModule&lt; DIM &gt; class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>LSMLIB::BoundaryConditionModule&lt; DIM &gt; Class Template Reference</h1>The <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> provides support for several common boundary conditions for level set functions: homogeneous Neumann, extrapolation, and anti-periodic boundary conditions. See the NOTES section for how to set periodic boundary conditions.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="BoundaryConditionModule_8h-source.html">BoundaryConditionModule.h</a>&gt;</code>
<p>
<a href="classLSMLIB_1_1BoundaryConditionModule-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#w5">BOUNDARY_CONDITION_TYPE</a> { <br>
&nbsp;&nbsp;<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#w5w0">NONE</a> =  0, 
<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#w5w1">HOMOGENEOUS_NEUMANN</a> =  1, 
<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#w5w2">LINEAR_EXTRAPOLATION</a> =  2, 
<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#w5w3">SIGNED_LINEAR_EXTRAPOLATION</a> =  3, 
<br>
&nbsp;&nbsp;<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#w5w4">ANTI_PERIODIC</a> =  4
<br>
 }</td></tr>

<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and destructor</div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z3_0">BoundaryConditionModule</a> (Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; patch_hierarchy, const  IntVector&lt; DIM &gt; &amp;ghostcell_width)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z3_1">BoundaryConditionModule</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z3_2">BoundaryConditionModule</a> (const  <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a>&lt; DIM &gt; &amp;rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z3_3">~BoundaryConditionModule</a> ()</td></tr>

<tr><td colspan="2"><div class="groupHeader">Methods for imposing boundary conditions</div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z5_0">imposeBoundaryConditions</a> (const  int phi_handle, const  IntVector&lt; DIM &gt; &amp;lower_bc, const  IntVector&lt; DIM &gt; &amp;upper_bc, const  <a class="el" href="namespaceLSMLIB.html#a6">SPATIAL_DERIVATIVE_TYPE</a> spatial_derivative_type, const  int spatial_derivative_order, const  int component=-1)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z5_1">imposeBoundaryConditionsOnPatch</a> (Patch&lt; DIM &gt; &amp;patch, const  int phi_handle, const  IntVector&lt; DIM &gt; &amp;lower_bc, const  IntVector&lt; DIM &gt; &amp;upper_bc, const  <a class="el" href="namespaceLSMLIB.html#a6">SPATIAL_DERIVATIVE_TYPE</a> spatial_derivative_type, const  int spatial_derivative_order, const  int component=-1)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z5_2">imposeAntiPeriodicBCs</a> (const  int phi_handle, const  IntVector&lt; DIM &gt; &amp;lower_bc, const  IntVector&lt; DIM &gt; &amp;upper_bc, const  int component=-1)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z5_3">imposeAntiPeriodicBCsOnPatch</a> (Patch&lt; DIM &gt; &amp;patch, const  int phi_handle, const  IntVector&lt; DIM &gt; &amp;lower_bc, const  IntVector&lt; DIM &gt; &amp;upper_bc, const  int component=-1)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z5_4">imposeHomogeneousNeumannBCs</a> (const  int phi_handle, const  IntVector&lt; DIM &gt; &amp;lower_bc, const  IntVector&lt; DIM &gt; &amp;upper_bc, const  <a class="el" href="namespaceLSMLIB.html#a6">SPATIAL_DERIVATIVE_TYPE</a> spatial_derivative_type, const  int spatial_derivative_order, const  int component=-1)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z5_5">imposeHomogeneousNeumannBCsOnPatch</a> (Patch&lt; DIM &gt; &amp;patch, const  int phi_handle, const  IntVector&lt; DIM &gt; &amp;lower_bc, const  IntVector&lt; DIM &gt; &amp;upper_bc, const  <a class="el" href="namespaceLSMLIB.html#a6">SPATIAL_DERIVATIVE_TYPE</a> spatial_derivative_type, const  int spatial_derivative_order, const  int component=-1)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z5_6">imposeLinearExtrapolationBCs</a> (const  int phi_handle, const  IntVector&lt; DIM &gt; &amp;lower_bc, const  IntVector&lt; DIM &gt; &amp;upper_bc, const  int component=-1)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z5_7">imposeLinearExtrapolationBCsOnPatch</a> (Patch&lt; DIM &gt; &amp;patch, const  int phi_handle, const  IntVector&lt; DIM &gt; &amp;lower_bc, const  IntVector&lt; DIM &gt; &amp;upper_bc, const  int component=-1)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z5_8">imposeSignedLinearExtrapolationBCs</a> (const  int phi_handle, const  IntVector&lt; DIM &gt; &amp;lower_bc, const  IntVector&lt; DIM &gt; &amp;upper_bc, const  int component=-1)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z5_9">imposeSignedLinearExtrapolationBCsOnPatch</a> (Patch&lt; DIM &gt; &amp;patch, const  int phi_handle, const  IntVector&lt; DIM &gt; &amp;lower_bc, const  IntVector&lt; DIM &gt; &amp;upper_bc, const  int component=-1)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Methods for managing the grid configuration</div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z7_0">resetHierarchyConfiguration</a> (const  Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; patch_hierarchy, const  int coarsest_level, const  int finest_level, const  IntVector&lt; DIM &gt; &amp;ghostcell_width)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Operators</div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual const  <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z9_0">operator=</a> (const  <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a>&lt; DIM &gt; &amp;rhs)</td></tr>

<tr><td colspan=2><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Static helper methods</div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z11_0">computeIndexSpaceOfNearestGhostLayer</a> (IntVector&lt; DIM &gt; &amp;nearest_ghost_layer_lo, IntVector&lt; DIM &gt; &amp;nearest_ghost_layer_hi, const  int bdry_type, const  int bdry_location_idx, const  Box&lt; DIM &gt; &amp;fillbox)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z11_1">computeIndexOffset</a> (const  int bdry_type, const  int bdry_location_idx, const  Box&lt; DIM &gt; &amp;ghostbox)</td></tr>

<tr><td colspan=2><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#p0">d_patch_hierarchy</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>IntVector&lt; DIM &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#p1">d_ghostcell_width</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>IntVector&lt; DIM &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#p2">d_geom_periodic_dirs</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>Array&lt; Array&lt; Array&lt; BoundaryBox&lt;<br>
 DIM &gt; &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#p3">d_boundary_boxes</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>Array&lt; Array&lt; bool &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#p4">d_touches_boundary</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int DIM&gt;<br>
 class LSMLIB::BoundaryConditionModule&lt; DIM &gt;</h3>

The <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> provides support for several common boundary conditions for level set functions: homogeneous Neumann, extrapolation, and anti-periodic boundary conditions. See the NOTES section for how to set periodic boundary conditions. 
<p>
In more detail, these boundary conditions are:<p>
<ul>
<li>Homogeneous Neumann boundary conditions set the ghost cells for the specified data so that the normal derivative of the level set function at the boundary to zero. The ghost cells are set in a manner that accounts for the type and order of the discretization used to compute spatial derivatives. For ENO1, ENO2, ENO3, and WENO5, this module simply fills ghost cells with data from the nearest neighbor in the interior of the computational domain.</li></ul>
<p>
<ul>
<li>Extrapolation boundary conditions extend the level set functions into the ghost cells using simple extrapolation schemes. There are two types of extrapolation boundary conditions: unsigned and signed. Unsigned extrapolation boundary conditions extend the level set function using a simple linear extrapolation in the direction normal to the boundary. Signed extrapolation also extends the level set function values using a linear function, but the sign of the slope at the boundary is chosen to guarantee that the extrapolated level set function does not have a value of zero in the extrapolation direction.</li></ul>
<p>
<ul>
<li>Anti-periodic boundary conditions are periodic boundary conditions where the sign of the function changes across the "anti-periodic" boundary. These boundary conditions are important when the sign of the level set function changes across the periodic boundary to avoid introducing artificial zero-level sets into the level set functions at the periodic boundary.</li></ul>
<p>
When the sign of the level set function in the interior of the computational domain is the same on both sides of a periodic boundary, then the values in the ghostcells outside of the physical domain are set equal to the value of the grid cells taken from grid cells on the other side of the computational domain. However, when the sign of the level set function in the interior of the computational domain changes across a periodic boundary, the values in the ghostcells outside of the physical domain are set to minus the value of the grid cells taken from grid cells on the other side of the computational domain.<p>
<h3>NOTES: </h3>
<p>
<ul>
<li>To impose PERIODIC boundary conditions in a coordinate direction, set that coordinate direction to be a periodic direction for the CartesianGridGeometry object (may be set in the input file) and set the boundary condition type to NONE.</li></ul>
<p>
<ul>
<li>In order for anti-periodic boundary conditions to be used in a coordinate direction, the GridGeometry associated with the PatchHierarchy MUST be set to be periodic in that coordinate direction. This ensures that data is properly transferred from the interior grid cells at the opposite side of the computational grid.</li></ul>
<p>
<ul>
<li>To guarantee that anti-periodic boundary conditions are correctly imposed, the level set function must truly be anti-periodic. In particular, the initial conditions for the level set functions MUST be anti-periodic. It is the user's responsibility to ensure that the initial conditions for level set functions are appropriately set when s/he chooses to impose anti-periodic boundary conditions. </li></ul>

<p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="w5" doxytag="LSMLIB::BoundaryConditionModule::BOUNDARY_CONDITION_TYPE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#w5">LSMLIB::BoundaryConditionModule::BOUNDARY_CONDITION_TYPE</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enumerated type for types of boundary conditions provided by the <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> class.<p>
NOTES:<ul>
<li>To impose PERIODIC boundary conditions in a coordinate direction, set that coordinate direction to be a periodic direction for the CartesianGridGeometry object (may be set in the input file) and set the boundary condition type to NONE. </li></ul>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="w5w0" doxytag="NONE" ></a>NONE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="w5w1" doxytag="HOMOGENEOUS_NEUMANN" ></a>HOMOGENEOUS_NEUMANN</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="w5w2" doxytag="LINEAR_EXTRAPOLATION" ></a>LINEAR_EXTRAPOLATION</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="w5w3" doxytag="SIGNED_LINEAR_EXTRAPOLATION" ></a>SIGNED_LINEAR_EXTRAPOLATION</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="w5w4" doxytag="ANTI_PERIODIC" ></a>ANTI_PERIODIC</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="z3_0" doxytag="LSMLIB::BoundaryConditionModule::BoundaryConditionModule" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">LSMLIB::BoundaryConditionModule</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>patch_hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>ghostcell_width</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The standard constructor initializes the <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> using the specified parameters.<p>
Arguments: none<p>
NOTES:<ul>
<li>If the patch_hierarchy has not yet been constructed (i.e. number of levels == 0), then the <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> is set to be in an invalid state. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z3_1" doxytag="LSMLIB::BoundaryConditionModule::BoundaryConditionModule" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">LSMLIB::BoundaryConditionModule</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Default constructor initializes the <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> to an invalid state.<p>
Arguments: none     </td>
  </tr>
</table>
<a class="anchor" name="z3_2" doxytag="LSMLIB::BoundaryConditionModule::BoundaryConditionModule" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">LSMLIB::BoundaryConditionModule</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>rhs</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy constructor.<p>
Arguments:<ul>
<li>rhs (in): <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> object to copy </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z3_3" doxytag="LSMLIB::BoundaryConditionModule::~BoundaryConditionModule" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">LSMLIB::BoundaryConditionModule</a>&lt; DIM &gt;::~<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructor does nothing     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="z11_1" doxytag="LSMLIB::BoundaryConditionModule::computeIndexOffset" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">LSMLIB::BoundaryConditionModule</a>&lt; DIM &gt;::computeIndexOffset </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname" nowrap> <em>bdry_type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>bdry_location_idx</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const Box&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>ghostbox</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z11_1">computeIndexOffset()</a> computes the offset in the data array between the ghost cell nearest the interior of the computational domain and the first interior cell.<p>
Arguments:<ul>
<li>bdry_type (in): boundary type (see <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> documentation for definition)</li><li>bdry_location_idx (in): boundary location index (see <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> documentation for definition)</li><li>ghostbox (in): box of ghost-cells to fill</li></ul>
<p>
Return value: none     </td>
  </tr>
</table>
<a class="anchor" name="z11_0" doxytag="LSMLIB::BoundaryConditionModule::computeIndexSpaceOfNearestGhostLayer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">LSMLIB::BoundaryConditionModule</a>&lt; DIM &gt;::computeIndexSpaceOfNearestGhostLayer </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>nearest_ghost_layer_lo</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>nearest_ghost_layer_hi</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>bdry_type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>bdry_location_idx</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const Box&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>fillbox</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z11_0">computeIndexSpaceOfNearestGhostLayer()</a> computes the index space of the layer of ghost cells nearest the interior of the computational domain.<p>
Arguments:<ul>
<li>nearest_ghost_layer_lo (out): lower corner of box that represents the index space of ghost-cell layer nearest the boundary specified box to fill</li><li>nearest_ghost_layer_hi (out): upper corner of box that represents the index space of ghost-cell layer nearest the boundary specified box to fill</li><li>bdry_type (in): boundary type (see <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> documentation for definition)</li><li>bdry_location_idx (in): boundary location index (see <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> documentation for definition)</li><li>fillbox (in): box (of ghost-cells) to fill</li></ul>
<p>
Return value: none     </td>
  </tr>
</table>
<a class="anchor" name="z5_2" doxytag="LSMLIB::BoundaryConditionModule::imposeAntiPeriodicBCs" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">LSMLIB::BoundaryConditionModule</a>&lt; DIM &gt;::imposeAntiPeriodicBCs </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lower_bc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>upper_bc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>component</em> = -1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z5_2">imposeAntiPeriodicBCs()</a> imposes "anti-periodic" boundary conditions at periodic boundaries where the sign of a level set function changes.<p>
Arguments:<ul>
<li>phi_handle (in): PatchData handle for function on which to impose anti-periodic boundary conditions</li><li>lower_bc (in): vector of integers specifying the type of boundary conditions to impose on the lower face of the computational domain in each coordinate direction. The i-th entry should contain the type of boundary condition to impose at the lower boundary in the i-th coordinate direction.</li><li>upper_bc (in): vector of integers specifying the type of boundary conditions to impose on the upper face of the computational domain in each coordinate direction. The i-th entry should contain the type of boundary condition to impose at the upper boundary in the i-th coordinate direction.</li><li>component (in): component of phi on which to impose anti-periodic boundary conditions (default = -1)</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>Anti-periodic boundary conditions are only imposed for those directions that are specified by lower_bc and upper_bc AND that are periodic directions for the GridGeometry object associated with the PatchHierarchy set in the constructor or by <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z7_0">resetHierarchyConfiguration()</a>. If a direction is specified to be anti-periodic by the lower_bc and upper_bc variables but is not a periodic direction for the GridGeometry object, then that direction is NOT treated as an anti-periodic direction.</li></ul>
<p>
<ul>
<li>This method assumes that ghostcells for ALL patches have already been correctly filled for true periodic boundary conditions (e.g. via <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> communication routines such as fillData()). This method merely corrects the sign of the ghostcell values when the level set function is anti-periodic across the periodic boundary.</li></ul>
<p>
<ul>
<li>The number of ghostcells for the data associated with phi_handle MUST be equal to the ghostcell_width in the specified in the constructor or <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z7_0">resetHierarchyConfiguration()</a> method. It is the user's responsibility to ensure that the current configuration of the <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> is compatible with the phi data.</li></ul>
<p>
<ul>
<li>When component is negative, anti-periodic boundary conditions will be imposed on ALL of the components of phi. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z5_3" doxytag="LSMLIB::BoundaryConditionModule::imposeAntiPeriodicBCsOnPatch" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">LSMLIB::BoundaryConditionModule</a>&lt; DIM &gt;::imposeAntiPeriodicBCsOnPatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Patch&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>patch</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lower_bc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>upper_bc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>component</em> = -1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z5_3">imposeAntiPeriodicBCsOnPatch()</a> imposes "anti-periodic" boundary conditions on the specified Patch at periodic boundaries where the sign of a level set function changes.<p>
Arguments:<ul>
<li>patch (in): Patch on which set boundary conditions</li><li>phi_handle (in): PatchData handle for function on which to impose anti-periodic boundary conditions</li><li>lower_bc (in): vector of integers specifying the type of boundary conditions to impose on the lower face of the computational domain in each coordinate direction. The i-th entry should contain the type of boundary condition to impose at the lower boundary in the i-th coordinate direction.</li><li>upper_bc (in): vector of integers specifying the type of boundary conditions to impose on the upper face of the computational domain in each coordinate direction. The i-th entry should contain the type of boundary condition to impose at the upper boundary in the i-th coordinate direction.</li><li>component (in): component of phi on which to impose anti-periodic boundary conditions (default = -1)</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>Anti-periodic boundary conditions are only imposed for those directions that are specified by lower_bc and upper_bc AND that are periodic directions for the GridGeometry object associated with the PatchHierarchy set in the constructor or by <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z7_0">resetHierarchyConfiguration()</a>. If a direction is specified to be anti-periodic by the lower_bc and upper_bc variables but is not a periodic direction for the GridGeometry object, then that direction is NOT treated as an anti-periodic direction.</li></ul>
<p>
<ul>
<li>This method assumes that ghostcells for ALL patches have already been correctly filled for true periodic boundary conditions (e.g. via <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> communication routines such as fillData()). This method merely corrects the sign of the ghostcell values when the level set function is anti-periodic across the periodic boundary.</li></ul>
<p>
<ul>
<li>The number of ghostcells for the data associated with phi_handle MUST be equal to the ghostcell_width in the specified in the constructor or <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z7_0">resetHierarchyConfiguration()</a> method. It is the user's responsibility to ensure that the current configuration of the <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> is compatible with the phi data.</li></ul>
<p>
<ul>
<li>When component is negative, anti-periodic boundary conditions will be imposed on ALL of the components of phi. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z5_0" doxytag="LSMLIB::BoundaryConditionModule::imposeBoundaryConditions" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">LSMLIB::BoundaryConditionModule</a>&lt; DIM &gt;::imposeBoundaryConditions </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lower_bc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>upper_bc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="namespaceLSMLIB.html#a6">SPATIAL_DERIVATIVE_TYPE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_derivative_type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_derivative_order</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>component</em> = -1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z5_0">imposeBoundaryConditions()</a> imposes the specified boundary conditions for phi on the entire PatchHierarchy.<p>
Arguments:<ul>
<li>phi_handle (in): PatchData handle for function on which to impose boundary conditions</li><li>lower_bc (in): vector of integers specifying the type of boundary conditions to impose on the lower face of the computational domain in each coordinate direction. The i-th entry should contain the type of boundary condition to impose at the lower boundary in the i-th coordinate direction.</li><li>upper_bc (in): vector of integers specifying the type of boundary conditions to impose on the upper face of the computational domain in each coordinate direction. The i-th entry should contain the type of boundary condition to impose at the upper boundary in the i-th coordinate direction.</li><li>spatial_derivative_type (in): type of spatial derivative calculation</li><li>spatial_derivative_order (in): order of spatial derivative</li><li>component (in): component of phi on which to impose boundary conditions (default = -1)</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>The number of ghostcells for the data associated with phi_handle MUST be equal to the ghostcell_width in the specified in the constructor or <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z7_0">resetHierarchyConfiguration()</a> method. It is the user's responsibility to ensure that the current configuration of the <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> is compatible with the phi data.</li></ul>
<p>
<ul>
<li>The spatial derivative information is only used for imposing homogeneous Neumann boundary conditions.</li></ul>
<p>
<ul>
<li>The default behavior when no boundary conditions are supplied (i.e. either lower_bc or upper_bc is a vector of -1's) is that homogeneous Neumann boundary conditions will be imposed on all non-periodic boundaries.</li></ul>
<p>
<ul>
<li>When component is negative, boundary conditions will be imposed on ALL of the components of phi. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z5_1" doxytag="LSMLIB::BoundaryConditionModule::imposeBoundaryConditionsOnPatch" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">LSMLIB::BoundaryConditionModule</a>&lt; DIM &gt;::imposeBoundaryConditionsOnPatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Patch&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>patch</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lower_bc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>upper_bc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="namespaceLSMLIB.html#a6">SPATIAL_DERIVATIVE_TYPE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_derivative_type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_derivative_order</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>component</em> = -1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z5_1">imposeBoundaryConditionsOnPatch()</a> imposes the specified boundary conditions for phi on the specified patch.<p>
Arguments:<ul>
<li>patch (in): Patch on which set boundary conditions</li><li>phi_handle (in): PatchData handle for function on which to impose boundary conditions</li><li>lower_bc (in): vector of integers specifying the type of boundary conditions to impose on the lower face of the computational domain in each coordinate direction. The i-th entry should contain the type of boundary condition to impose at the lower boundary in the i-th coordinate direction.</li><li>upper_bc (in): vector of integers specifying the type of boundary conditions to impose on the upper face of the computational domain in each coordinate direction. The i-th entry should contain the type of boundary condition to impose at the upper boundary in the i-th coordinate direction.</li><li>spatial_derivative_type (in): type of spatial derivative calculation</li><li>spatial_derivative_order (in): order of spatial derivative</li><li>component (in): component of phi on which to impose boundary conditions (default = -1)</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>The number of ghostcells for the data associated with phi_handle MUST be equal to the ghostcell_width in the specified in the constructor or <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z7_0">resetHierarchyConfiguration()</a> method. It is the user's responsibility to ensure that the current configuration of the <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> is compatible with the phi data.</li></ul>
<p>
<ul>
<li>The spatial derivative information is only used for imposing homogeneous Neumann boundary conditions.</li></ul>
<p>
<ul>
<li>The default behavior when no boundary conditions are supplied (i.e. either lower_bc or upper_bc is a vector of -1's) is that homogeneous Neumann boundary conditions will be imposed on all non-periodic boundaries.</li></ul>
<p>
<ul>
<li>When component is negative, boundary conditions will be imposed on ALL of the components of phi. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z5_4" doxytag="LSMLIB::BoundaryConditionModule::imposeHomogeneousNeumannBCs" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">LSMLIB::BoundaryConditionModule</a>&lt; DIM &gt;::imposeHomogeneousNeumannBCs </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lower_bc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>upper_bc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="namespaceLSMLIB.html#a6">SPATIAL_DERIVATIVE_TYPE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_derivative_type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_derivative_order</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>component</em> = -1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z5_4">imposeHomogeneousNeumannBCs()</a> imposes homogeneous Neumann boundary conditions at the specified boundary locations.<p>
Arguments:<ul>
<li>phi_handle (in): PatchData handle for function on which to impose homogeneous Neumann boundary conditions</li><li>lower_bc (in): vector of integers specifying the type of boundary conditions to impose on the lower face of the computational domain in each coordinate direction. The i-th entry should contain the type of boundary condition to impose at the lower boundary in the i-th coordinate direction.</li><li>upper_bc (in): vector of integers specifying the type of boundary conditions to impose on the upper face of the computational domain in each coordinate direction. The i-th entry should contain the type of boundary condition to impose at the upper boundary in the i-th coordinate direction.</li><li>spatial_derivative_type (in): spatial derivative type</li><li>spatial_derivative_order (in): spatial derivative order</li><li>component (in): component of phi on which to impose homogeneous Neumann boundary conditions (default = -1)</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>It is the user's responsibility to ensure that the data associated with phi_handle is sufficient for imposing a homogeneous Neumann boundary condition for the specified discretization of the spatial derivative.</li></ul>
<p>
<ul>
<li>The number of ghostcells for the data associated with phi_handle MUST be equal to the ghostcell_width in the specified in the constructor or <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z7_0">resetHierarchyConfiguration()</a> method. It is the user's responsibility to ensure that the current configuration of the <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> is compatible with the phi data.</li></ul>
<p>
<ul>
<li>When component is negative, boundary conditions will be imposed for ALL components of phi. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z5_5" doxytag="LSMLIB::BoundaryConditionModule::imposeHomogeneousNeumannBCsOnPatch" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">LSMLIB::BoundaryConditionModule</a>&lt; DIM &gt;::imposeHomogeneousNeumannBCsOnPatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Patch&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>patch</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lower_bc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>upper_bc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="namespaceLSMLIB.html#a6">SPATIAL_DERIVATIVE_TYPE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_derivative_type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_derivative_order</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>component</em> = -1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z5_5">imposeHomogeneousNeumannBCsOnPatch()</a> imposes homogeneous Neumann boundary conditions at the specified boundary locations on the specified Patch.<p>
Arguments:<ul>
<li>patch (in): Patch on which set boundary conditions</li><li>phi_handle (in): PatchData handle for function on which to impose homogeneous Neumann boundary conditions</li><li>lower_bc (in): vector of integers specifying the type of boundary conditions to impose on the lower face of the computational domain in each coordinate direction. The i-th entry should contain the type of boundary condition to impose at the lower boundary in the i-th coordinate direction.</li><li>upper_bc (in): vector of integers specifying the type of boundary conditions to impose on the upper face of the computational domain in each coordinate direction. The i-th entry should contain the type of boundary condition to impose at the upper boundary in the i-th coordinate direction.</li><li>spatial_derivative_type (in): spatial derivative type</li><li>spatial_derivative_order (in): spatial derivative order</li><li>component (in): component of phi on which to impose homogeneous Neumann boundary conditions (default = -1)</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>It is the user's responsibility to ensure that the data associated with phi_handle is sufficient for imposing a homogeneous Neumann boundary condition for the specified discretization of the spatial derivative.</li></ul>
<p>
<ul>
<li>The number of ghostcells for the data associated with phi_handle MUST be equal to the ghostcell_width in the specified in the constructor or <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z7_0">resetHierarchyConfiguration()</a> method. It is the user's responsibility to ensure that the current configuration of the <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> is compatible with the phi data.</li></ul>
<p>
<ul>
<li>When component is negative, boundary conditions will be imposed for ALL components of phi. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z5_6" doxytag="LSMLIB::BoundaryConditionModule::imposeLinearExtrapolationBCs" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">LSMLIB::BoundaryConditionModule</a>&lt; DIM &gt;::imposeLinearExtrapolationBCs </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lower_bc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>upper_bc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>component</em> = -1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z5_6">imposeLinearExtrapolationBCs()</a> imposes linear extrapolation boundary conditions at the specified boundary locations.<p>
Arguments:<ul>
<li>phi_handle (in): PatchData handle for function on which to impose linear extrapolation boundary conditions</li><li>lower_bc (in): vector of integers specifying the type of boundary conditions to impose on the lower face of the computational domain in each coordinate direction. The i-th entry should contain the type of boundary condition to impose at the lower boundary in the i-th coordinate direction.</li><li>upper_bc (in): vector of integers specifying the type of boundary conditions to impose on the upper face of the computational domain in each coordinate direction. The i-th entry should contain the type of boundary condition to impose at the upper boundary in the i-th coordinate direction.</li><li>component (in): component of phi on which to impose linear extrapolation boundary conditions (default = -1)</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>The number of ghostcells for the data associated with phi_handle MUST be equal to the ghostcell_width in the specified in the constructor or <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z7_0">resetHierarchyConfiguration()</a> method. It is the user's responsibility to ensure that the current configuration of the <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> is compatible with the phi data.</li></ul>
<p>
<ul>
<li>When component is negative, boundary conditions will be imposed for ALL components of phi. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z5_7" doxytag="LSMLIB::BoundaryConditionModule::imposeLinearExtrapolationBCsOnPatch" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">LSMLIB::BoundaryConditionModule</a>&lt; DIM &gt;::imposeLinearExtrapolationBCsOnPatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Patch&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>patch</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lower_bc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>upper_bc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>component</em> = -1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z5_7">imposeLinearExtrapolationBCsOnPatch()</a> imposes linear extrapolation boundary conditions at the specified boundary locations on the specified Patch.<p>
Arguments:<ul>
<li>patch (in): Patch on which set boundary conditions</li><li>phi_handle (in): PatchData handle for function on which to impose linear extrapolation boundary conditions</li><li>lower_bc (in): vector of integers specifying the type of boundary conditions to impose on the lower face of the computational domain in each coordinate direction. The i-th entry should contain the type of boundary condition to impose at the lower boundary in the i-th coordinate direction.</li><li>upper_bc (in): vector of integers specifying the type of boundary conditions to impose on the upper face of the computational domain in each coordinate direction. The i-th entry should contain the type of boundary condition to impose at the upper boundary in the i-th coordinate direction.</li><li>component (in): component of phi on which to impose linear extrapolation boundary conditions (default = -1)</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>The number of ghostcells for the data associated with phi_handle MUST be equal to the ghostcell_width in the specified in the constructor or <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z7_0">resetHierarchyConfiguration()</a> method. It is the user's responsibility to ensure that the current configuration of the <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> is compatible with the phi data.</li></ul>
<p>
<ul>
<li>When component is negative, boundary conditions will be imposed for ALL components of phi. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z5_8" doxytag="LSMLIB::BoundaryConditionModule::imposeSignedLinearExtrapolationBCs" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">LSMLIB::BoundaryConditionModule</a>&lt; DIM &gt;::imposeSignedLinearExtrapolationBCs </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lower_bc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>upper_bc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>component</em> = -1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z5_8">imposeSignedLinearExtrapolationBCs()</a> imposes signed-linear extrapolation boundary conditions at the specified boundary locations.<p>
Arguments:<ul>
<li>phi_handle (in): PatchData handle for function on which to impose signed linear extrapolation boundary conditions</li><li>lower_bc (in): vector of integers specifying the type of boundary conditions to impose on the lower face of the computational domain in each coordinate direction. The i-th entry should contain the type of boundary condition to impose at the lower boundary in the i-th coordinate direction.</li><li>upper_bc (in): vector of integers specifying the type of boundary conditions to impose on the upper face of the computational domain in each coordinate direction. The i-th entry should contain the type of boundary condition to impose at the upper boundary in the i-th coordinate direction.</li><li>component (in): component of phi on which to impose signed linear extrapolation boundary conditions (default = -1)</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>The number of ghostcells for the data associated with phi_handle MUST be equal to the ghostcell_width in the specified in the constructor or <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z7_0">resetHierarchyConfiguration()</a> method. It is the user's responsibility to ensure that the current configuration of the <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> is compatible with the phi data.</li></ul>
<p>
<ul>
<li>When component is negative, boundary conditions will be imposed for ALL components of phi. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z5_9" doxytag="LSMLIB::BoundaryConditionModule::imposeSignedLinearExtrapolationBCsOnPatch" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">LSMLIB::BoundaryConditionModule</a>&lt; DIM &gt;::imposeSignedLinearExtrapolationBCsOnPatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Patch&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>patch</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lower_bc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>upper_bc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>component</em> = -1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z5_9">imposeSignedLinearExtrapolationBCsOnPatch()</a> imposes signed-linear extrapolation boundary conditions at the specified boundary locations on the specified Patch.<p>
Arguments:<ul>
<li>patch (in): Patch on which set boundary conditions</li><li>phi_handle (in): PatchData handle for function on which to impose signed linear extrapolation boundary conditions</li><li>lower_bc (in): vector of integers specifying the type of boundary conditions to impose on the lower face of the computational domain in each coordinate direction. The i-th entry should contain the type of boundary condition to impose at the lower boundary in the i-th coordinate direction.</li><li>upper_bc (in): vector of integers specifying the type of boundary conditions to impose on the upper face of the computational domain in each coordinate direction. The i-th entry should contain the type of boundary condition to impose at the upper boundary in the i-th coordinate direction.</li><li>component (in): component of phi on which to impose signed linear extrapolation boundary conditions (default = -1)</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>The number of ghostcells for the data associated with phi_handle MUST be equal to the ghostcell_width in the specified in the constructor or <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z7_0">resetHierarchyConfiguration()</a> method. It is the user's responsibility to ensure that the current configuration of the <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> is compatible with the phi data.</li></ul>
<p>
<ul>
<li>When component is negative, boundary conditions will be imposed for ALL components of phi. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z9_0" doxytag="LSMLIB::BoundaryConditionModule::operator=" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual const <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a>&amp; <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">LSMLIB::BoundaryConditionModule</a>&lt; DIM &gt;::operator= </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>rhs</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Assignment operator.<p>
Arguments:<ul>
<li>rhs (in): <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> to copy</li></ul>
<p>
Return value: *this     </td>
  </tr>
</table>
<a class="anchor" name="z7_0" doxytag="LSMLIB::BoundaryConditionModule::resetHierarchyConfiguration" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">LSMLIB::BoundaryConditionModule</a>&lt; DIM &gt;::resetHierarchyConfiguration </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>patch_hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>coarsest_level</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>finest_level</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>ghostcell_width</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#z7_0">resetHierarchyConfiguration()</a> resets the configuration of the <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> to be consistent with the specified PatchHierarchy. In particular, it computes ALL of the boundary boxes (both periodic and non-periodic) that need to be filled. The <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> library internally carries out the same calculation, but it is necessary to repeat this calculation in order to impose anti-periodic boundary conditions at periodic boundaries across which level set functions change sign.<p>
Arguments:<ul>
<li>patch_hierarchy (in): PatchHierarchy to reconfigure</li><li>coarsest_level (in): coarsest level in hierarchy to reconfigure</li><li>finest_level (in): finest level in hierarchy to reconfigure</li><li>ghostcell_width (in): width of ghostcell required for boundary conditions</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>If the patch_hierarchy has not yet been constructed (i.e. number of levels == 0), then the <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> is set to be in an invalid state. </li></ul>
    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="p3" doxytag="LSMLIB::BoundaryConditionModule::d_boundary_boxes" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Array&lt; Array&lt; Array&lt; BoundaryBox&lt;DIM&gt; &gt; &gt; &gt; <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">LSMLIB::BoundaryConditionModule</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#p3">d_boundary_boxes</a><code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p2" doxytag="LSMLIB::BoundaryConditionModule::d_geom_periodic_dirs" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> IntVector&lt;DIM&gt; <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">LSMLIB::BoundaryConditionModule</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#p2">d_geom_periodic_dirs</a><code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p1" doxytag="LSMLIB::BoundaryConditionModule::d_ghostcell_width" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> IntVector&lt;DIM&gt; <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">LSMLIB::BoundaryConditionModule</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#p1">d_ghostcell_width</a><code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p0" doxytag="LSMLIB::BoundaryConditionModule::d_patch_hierarchy" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Pointer&lt; PatchHierarchy&lt;DIM&gt; &gt; <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">LSMLIB::BoundaryConditionModule</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#p0">d_patch_hierarchy</a><code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p4" doxytag="LSMLIB::BoundaryConditionModule::d_touches_boundary" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Array&lt; Array&lt;bool&gt; &gt; <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">LSMLIB::BoundaryConditionModule</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html#p4">d_touches_boundary</a><code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="BoundaryConditionModule_8h-source.html">BoundaryConditionModule.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Sun May 3 19:14:23 2009 for LSMLIB by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
