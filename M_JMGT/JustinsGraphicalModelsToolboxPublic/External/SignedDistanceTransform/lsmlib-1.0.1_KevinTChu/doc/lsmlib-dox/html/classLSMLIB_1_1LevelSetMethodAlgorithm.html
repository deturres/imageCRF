<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LSMLIB:  TemplateLSMLIB::LevelSetMethodAlgorithm&lt; DIM &gt; class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>LSMLIB::LevelSetMethodAlgorithm&lt; DIM &gt; Class Template Reference</h1>The <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a> class provides a simple interface for using the LevelSetMethod classes to capture the dynamics of implicit surfaces and curves in one-, two- and three-dimensions. It also provides support for vector level set method calculations.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="LevelSetMethodAlgorithm_8h-source.html">LevelSetMethodAlgorithm.h</a>&gt;</code>
<p>
<a href="classLSMLIB_1_1LevelSetMethodAlgorithm-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructor and destructor</div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z63_0">LevelSetMethodAlgorithm</a> (Pointer&lt; Database &gt; lsm_algorithm_input_db, Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; patch_hierarchy, <a class="el" href="classLSMLIB_1_1LevelSetMethodPatchStrategy.html">LevelSetMethodPatchStrategy</a>&lt; DIM &gt; *patch_strategy, <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LevelSetMethodVelocityFieldStrategy</a>&lt; DIM &gt; *velocity_field_strategy, const  int num_level_set_fcn_components=1, const  int codimension=1, const  string &amp;object_name="LevelSetMethodAlgorithm")</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z63_1">LevelSetMethodAlgorithm</a> (Pointer&lt; <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegratorStrategy.html">LevelSetFunctionIntegratorStrategy</a>&lt; DIM &gt; &gt; lsm_integrator_strategy, Pointer&lt; <a class="el" href="classLSMLIB_1_1LevelSetMethodGriddingStrategy.html">LevelSetMethodGriddingStrategy</a>&lt; DIM &gt; &gt; lsm_gridding_strategy, const  string &amp;object_name="LevelSetMethodAlgorithm")</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z63_2">~LevelSetMethodAlgorithm</a> ()</td></tr>

<tr><td colspan="2"><div class="groupHeader">Accessor methods for level set functions and related data</div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z65_0">getPhiPatchDataHandle</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z65_1">getPsiPatchDataHandle</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z65_2">getControlVolumePatchDataHandle</a> () const </td></tr>

<tr><td colspan="2"><div class="groupHeader">Accessor methods for simulation state</div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual LSMLIB_REAL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z67_0">getStartTime</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual LSMLIB_REAL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z67_1">getEndTime</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual LSMLIB_REAL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z67_2">getCurrentTime</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z67_3">endTimeReached</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z67_4">numIntegrationStepsTaken</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z67_5">printClassData</a> (ostream &amp;os) const </td></tr>

<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z68_0">getSpatialDerivativeType</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z68_1">getSpatialDerivativeOrder</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z68_2">getTVDRungeKuttaOrder</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual LSMLIB_REAL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z68_3">getCFLNumber</a> () const </td></tr>

<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z69_0">setBoundaryConditions</a> (const  IntVector&lt; DIM &gt; &amp;lower_bc, const  IntVector&lt; DIM &gt; &amp;upper_bc, const  <a class="el" href="namespaceLSMLIB.html#a5">LEVEL_SET_FCN_TYPE</a> level_set_fcn, const  int component=-1)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Methods for time advancing level set functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z71_0">initializeLevelSetMethodCalculation</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual LSMLIB_REAL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z71_1">computeStableDt</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z71_2">advanceLevelSetFunctions</a> (const  LSMLIB_REAL dt)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Reinitialization and orthogonalization methods</div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z73_0">getReinitializationInterval</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z73_1">setReinitializationInterval</a> (const  int interval)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z73_2">reinitializeLevelSetFunctions</a> (const  <a class="el" href="namespaceLSMLIB.html#a5">LEVEL_SET_FCN_TYPE</a> level_set_fcn=LSMLIB::PHI, const  int max_iterations=-1)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z73_3">getOrthogonalizationInterval</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z73_4">setOrthogonalizationInterval</a> (const  int interval)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z73_5">orthogonalizeLevelSetFunctions</a> (const  <a class="el" href="namespaceLSMLIB.html#a5">LEVEL_SET_FCN_TYPE</a> level_set_fcn, const  int max_reinit_iterations=-1, const  int max_ortho_iterations=-1)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Methods for managing the grid configuration</div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z75_0">resetHierarchyConfiguration</a> (const  Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; hierarchy, const  int coarsest_level, const  int finest_level)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z75_1">regridPatchHierarchy</a> ()</td></tr>

<tr><td colspan="2"><div class="groupHeader">Methods for creating FieldExtensionAlgorithm objects</div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual Pointer&lt; <a class="el" href="classLSMLIB_1_1FieldExtensionAlgorithm.html">FieldExtensionAlgorithm</a>&lt;<br>
 DIM &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z77_0">getFieldExtensionAlgorithm</a> (Pointer&lt; Database &gt; input_db, const  int field_handle, const  <a class="el" href="namespaceLSMLIB.html#a5">LEVEL_SET_FCN_TYPE</a> level_set_fcn, const  string &amp;object_name="FieldExtensionAlgorithm")</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual Pointer&lt; <a class="el" href="classLSMLIB_1_1FieldExtensionAlgorithm.html">FieldExtensionAlgorithm</a>&lt;<br>
 DIM &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z77_1">getFieldExtensionAlgorithm</a> (const  int field_handle, const  <a class="el" href="namespaceLSMLIB.html#a5">LEVEL_SET_FCN_TYPE</a> level_set_fcn, <a class="el" href="namespaceLSMLIB.html#a6">SPATIAL_DERIVATIVE_TYPE</a> spatial_derivative_type=UNKNOWN, int spatial_derivative_order=0, int tvd_runge_kutta_order=0, LSMLIB_REAL cfl_number=0, const  LSMLIB_REAL stop_distance=0.0, const  int max_iterations=0, const  LSMLIB_REAL iteration_stop_tolerance=0.0, const  bool verbose_mode=false, const  string &amp;object_name="FieldExtensionAlgorithm")</td></tr>

<tr><td colspan=2><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>string&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#p0">d_object_name</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>Pointer&lt; <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegratorStrategy.html">LevelSetFunctionIntegratorStrategy</a>&lt;<br>
 DIM &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#p1">d_lsm_integrator_strategy</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>Pointer&lt; <a class="el" href="classLSMLIB_1_1LevelSetMethodGriddingStrategy.html">LevelSetMethodGriddingStrategy</a>&lt;<br>
 DIM &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#p2">d_lsm_gridding_strategy</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>Array&lt; Pointer&lt; <a class="el" href="classLSMLIB_1_1FieldExtensionAlgorithm.html">FieldExtensionAlgorithm</a>&lt;<br>
 DIM &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#p3">d_field_extension_alg_list</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#p4">d_patch_hierarchy</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#p5">d_using_standard_level_set_fcn_integrator</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="namespaceLSMLIB.html#a6">SPATIAL_DERIVATIVE_TYPE</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#p6">d_spatial_derivative_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#p7">d_spatial_derivative_order</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#p8">d_tvd_runge_kutta_order</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>LSMLIB_REAL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#p9">d_cfl_number</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int DIM&gt;<br>
 class LSMLIB::LevelSetMethodAlgorithm&lt; DIM &gt;</h3>

The <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a> class provides a simple interface for using the LevelSetMethod classes to capture the dynamics of implicit surfaces and curves in one-, two- and three-dimensions. It also provides support for vector level set method calculations. 
<p>
It provides the flexibility of (a) managing the level set method calculation with the standard <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> and <a class="el" href="classLSMLIB_1_1LevelSetMethodGriddingAlgorithm.html">LevelSetMethodGriddingAlgorithm</a> classes or (b) using custom integrator and gridding algorithm classes (by subclassing the <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegratorStrategy.html">LevelSetFunctionIntegratorStrategy</a> and <a class="el" href="classLSMLIB_1_1LevelSetMethodGriddingStrategy.html">LevelSetMethodGriddingStrategy</a> classes).<p>
For more details about the numerical algorithms used by the standard <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> class, see the documentation at the beginning of the header file for that class.<p>
<h3>NOTES </h3>
<p>
<ul>
<li>AMR is NOT yet supported. It is still currently under development.</li></ul>
<p>
<h3>USAGE </h3>
<p>
There are two ways to use the <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a>:<p>
(A) use the standard <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> and <a class="el" href="classLSMLIB_1_1LevelSetMethodGriddingAlgorithm.html">LevelSetMethodGriddingAlgorithm</a> classes or<p>
(B) use custom level set function integrator and level set method gridding algorithm classes that conform to the interfaces defined by the <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegratorStrategy.html">LevelSetFunctionIntegratorStrategy</a> and <a class="el" href="classLSMLIB_1_1LevelSetMethodGriddingStrategy.html">LevelSetMethodGriddingStrategy</a> classes.<p>
<h4>Method (A) </h4>
<p>
Method (A) should be sufficient for most applications. To use (A), an application developer should use the following steps:<p>
<ol>
<li>Provide a concrete implementation of the <a class="el" href="classLSMLIB_1_1LevelSetMethodPatchStrategy.html">LevelSetMethodPatchStrategy</a> class. This class must provide numerical routines for computations on a single patch (i.e., logically rectangular, uniform grid). In particular, methods must be provided for initialization of data, setting the physical boundary conditions for the level set functions, and computing a stable time step size for the next TVD Runge-Kutta time step. For more details, see the header file for the <a class="el" href="classLSMLIB_1_1LevelSetMethodPatchStrategy.html">LevelSetMethodPatchStrategy</a> class.</li><li>Provide a concrete implementation of the <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LevelSetMethodVelocityFieldStrategy</a> class. This class must provide routines associated with computing the velocity field that is used to advance the level set functions. In particular, methods must be provided for computing the velocity field used in a level set method calculation, computing a stable time step size based on the velocity field computation, initializing data required for the velocity computation, and returning the PatchData handle for the velocity field data. For more details, see the header file for the <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LevelSetMethodVelocityFieldStrategy</a> class.</li><li>Create a <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a> object using the constructor that takes pointers to <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LevelSetMethodVelocityFieldStrategy</a> and <a class="el" href="classLSMLIB_1_1LevelSetMethodPatchStrategy.html">LevelSetMethodPatchStrategy</a> objects as arguments.</li><li>Begin the level set method calculation by invoking the <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z71_0">initializeLevelSetMethodCalculation</a>() method. This will initialize the data on the PatchHierarchy.</li><li>Integrate the level set functions in time by invoking the <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z71_2">advanceLevelSetFunctions</a>() method for each time step. Stable time step sizes can be computed for each time step using the <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z71_1">computeStableDt</a>() method.</li><li>Access to level set function data and other integration data is available through several accessor method defined below.</li></ol>
<p>
Users interested in the details of the level set method calculation used by the <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> should consult the class definitions in the header files for the <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> and <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LevelSetMethodToolbox</a> classes.<p>
<h4>Method (B) </h4>
<p>
To use (B), an application developer should use the following steps:<p>
<ol>
<li>Implement a level set method integrator class that conforms to the interface defined by the <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegratorStrategy.html">LevelSetFunctionIntegratorStrategy</a> class.</li><li>Implement a level set gridding algorithm class that conforms to the interface defined by the <a class="el" href="classLSMLIB_1_1LevelSetMethodGriddingStrategy.html">LevelSetMethodGriddingStrategy</a> class.</li><li>Create a <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a> object using the constructor that takes a pointer to a <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegratorStrategy.html">LevelSetFunctionIntegratorStrategy</a> and a <a class="el" href="classLSMLIB_1_1LevelSetMethodGriddingStrategy.html">LevelSetMethodGriddingStrategy</a> as arguments.</li><li>Follow steps 4 through 6 from Method (A).</li></ol>
<p>
<h3>User-specified parameters (input database field) </h3>
<p>
When using the standard <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a>, it is possible to modify the behavior of the integrator through an input file. The input data parameters available for/required by the user are described below. In the input file, the <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> database and <a class="el" href="classLSMLIB_1_1LevelSetMethodGriddingAlgorithm.html">LevelSetMethodGriddingAlgorithm</a> database must be organized as separate sub-databases of a single, high-level <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a> database. That is, the input file should have the following form:<p>
<pre><div>
 <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a> {</pre></div><p>
<pre><div>   <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> {
     ... input parameters for <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> ...
   }</pre></div><p>
<pre><div>   <a class="el" href="classLSMLIB_1_1LevelSetMethodGriddingAlgorithm.html">LevelSetMethodGriddingAlgorithm</a> {
     ... input parameters for <a class="el" href="classLSMLIB_1_1LevelSetMethodGriddingAlgorithm.html">LevelSetMethodGriddingAlgorithm</a> ...
   }</pre></div><p>
<pre><div> } // end input database for <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a>
 </pre></div><p>
<h4><a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> Input Database Parameters </h4>
<p>
<h5>Level Set Method Parameters: </h5>
<p>
<ul>
<li>start_time = start time for calculation (default = 0.0)</li><li>end_time = end time for calculation (default = 10.0)</li><li>cfl_number = CFL number (default = 0.5)</li><li>spatial_derivative_type = type of spatial derivative (default = "WENO")</li><li>spatial_derivative_order = order of spatial derivative (default = 5)</li><li>tvd_runge_kutta_order = order of Runge-Kutta time integration (default = 3)</li><li>reinitialization_interval = interval between reinitialization (default = 10) (reinitialization disabled if &lt;= 0)</li><li>reinitialization_stop_tol = stopping criterion for termination of evolution of reinitialization equation. Reinitialization stops when the max norm of the change in the level set function drops below the specified tolerance.</li><li>reinitialization_stop_dist = approximate stopping criterion for reinitialization of level set functions. Reinitialization terminates after the information from the zero level set has propogated by approximately the specified distance.</li><li>reinitialization_max_iters = maximum number of time steps to take during the reinitialization process (default = 25)</li><li>orthogonalization_interval = interval between orthogonalizing phi and psi for codimension-two problems (default = 10) (orthogonalization disabled if &lt;= 0)</li><li>orthogonalization_stop_tol = stopping criterion for termination of evolution of orthogonalization equation. Orthogonalization stops when the max norm of the change in the level set function drops below the specified tolerance.</li><li>orthogonalization_stop_dist = approximate stopping criterion for orthogonalization of level set functions. Orthogonalization terminates after the information from the zero level set has propogated by approximately the specified distance.</li><li>orthogonalization_max_iters = maximum number of time steps to take during the orthogonalization process (default = 25)</li></ul>
<p>
<h5>Boundary Condition Parameters: </h5>
<p>
<ul>
<li>lower_bc_phi_[i] = boundary conditions for the lower face of the computational domain in each coordinate direction for the i-th component of the PHI level set function. lower_bc_phi_[i] is a vector of length DIM. The j-th entry should contain the type of boundary condition to impose at the lower boundary in the j-th coordinate direction. See NOTES ON INPUT PARAMETERS section for boundary condition types. For information about the boundary condition types, see documentation of the <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> class. (default = vector of zeros)</li><li>upper_bc_phi_[i] = boundary conditions for the upper face of the computational domain in each coordinate direction for the i-th component of the PHI level set function. upper_bc_phi_[i] is a vector of length DIM. The j-th entry should contain the type of boundary condition to impose at the upper boundary in the j-th coordinate direction. See NOTES ON INPUT PARAMETERS section for boundary condition types. For information about the boundary condition types, see documentation of the <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> class. (default = vector of zeros)</li><li>lower_bc_psi_[i] = boundary conditions for the lower face of the computational domain in each coordinate direction for the i-th component of the PSI level set function. lower_bc_psi_[i] is a vector of length DIM. The j-th entry should contain the type of boundary condition to impose at the lower boundary in the j-th coordinate direction. See NOTES ON INPUT PARAMETERS section for boundary condition types. For information about the boundary condition types, see documentation of the <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> class. (default = vector of zeros)</li><li>upper_bc_psi_[i] = boundary conditions for the upper face of the computational domain in each coordinate direction for the i-th component of the PSI level set function. upper_bc_psi_[i] is a vector of length DIM. The j-th entry should contain the type of boundary condition to impose at the upper boundary in the j-th coordinate direction. See NOTES ON INPUT PARAMETERS section for boundary condition types. For information about the boundary condition types, see documentation of the <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> class. (default = vector of zeros)</li></ul>
<p>
<h5>Miscellaneous Parameters: </h5>
<p>
<ul>
<li>verbose_mode = TRUE if status should be output during integration (default = TRUE)</li></ul>
<p>
<h5>AMR Parameters (CURRENTLY UNUSED): </h5>
<p>
<ul>
<li>use_AMR = TRUE if AMR should be used (default = FALSE)</li><li>regrid_interval = regridding interval (default = 5)</li><li>tag_buffer_width = number of buffer cells to use around cells tagged for refinement (default = 2)</li><li>refinement_cutoff_value = cutoff value for distance function (default = 1.0)</li></ul>
<p>
<h4><a class="el" href="classLSMLIB_1_1LevelSetMethodGriddingAlgorithm.html">LevelSetMethodGriddingAlgorithm</a> Input Database Parameters </h4>
<p>
<h5>Hierarchy Structure Input: </h5>
<p>
<ul>
<li>max_levels (REQUIRED) = integer value specifying maximum number of levels allowed in the AMR PatchHierarchy.</li><li>largest_patch_size (REQUIRED) = an array of integer vectors (each has length = DIM) that specify the dimensions of largest patch allowed on each level in the hierarchy. If more than max_levels entries are given, extra entries will be ignored. If fewer than max_levels entries are given, then the last element in the array will be used on each level without a specified input value.</li><li>ratio_to_coarser (REQUIRED) = set of (max_levels - 1) integer vectors, each of which indicates the ratio of the index space of a PatchLevel to that of the next coarser level. The input for each level must correspond to the format ``level_n = vector'', where n is the level number and each vector must have length DIM.</li></ul>
<p>
<h5>Adaptive Refinement Input (CURRENTLY UNUSED): </h5>
<p>
<ul>
<li>tagging_method (OPTIONAL) = string array specification of the type of cell-tagging used. Valid choices include: ``GRADIENT_DETECTOR'' and ``REFINE_BOXES''. A combination of any or all of the above may be placed in any order. If no input is given, no tagging will be performed.</li><li>RefineBoxes (OPTIONAL) = input section describing the refine boxes for each level.<ul>
<li>Level&lt;ln&gt; = input section provides the sequence of Box arrays describing where user-specified refinement is to occur on Level ln.<ul>
<li>times (OPTIONAL) = LSMLIB_REAL array specifying times at which a particular box sequence is to be used.</li><li>cycles (OPTIONAL) = integer array specifying regrid cycles at which a particular box seqence is to be used.</li><li>boxes_0 = box array specifying refine boxes for sequence 0.</li><li>boxes_1 = box array specifying refine boxes for sequence 1.</li><li>boxes_n = box array specifying refine boxes for sequence n.</li></ul>
</li></ul>
</li></ul>
<p>
<h5>Load Balancer Input: </h5>
<p>
<ul>
<li>NO REQUIRED INPUT PARAMETERS (several OPTIONAL input parameters)</li></ul>
<p>
<h4>NOTES ON INPUT PARAMETERS </h4>
<p>
<ul>
<li>When restarting a computation, the following input parameters override the values from the restart file: end_time, reinitialization_interval, reinitialization_stop_tol, reinitialization_stop_dist, reinitialization_max_iters, orthogonalization_interval, orthogonalization_stop_tol, orthogonalization_stop_dist, orthogonalization_max_iters, verbose</li></ul>
<p>
<ul>
<li>The precedence of the three input parameters for reinitialization and orthogonalization is as follows:<ol>
<li>if provided, the stop tolerance is used with a maximum number of iterations determined from the calculation in (b) or a default value of 1000 iterations (to avoid failure to terminate)</li><li>when both the stop distance and maximum number of iterations are specified, the one that results in the smaller number of iterations is used. when only one is specified, it is the sole parameter used to compute the maximum number of time steps to take when advancing the reinitialization/orthogonalization equation</li><li>when no stopping criteria are supplied, the maximum number of time steps taken defaults to 25.</li></ol>
</li></ul>
<p>
<ul>
<li>The names of the sub-databases, <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> and <a class="el" href="classLSMLIB_1_1LevelSetMethodGriddingAlgorithm.html">LevelSetMethodGriddingAlgorithm</a>, MUST be named exactly as above. The name of the top-level database, <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a>, may be arbitrary (it is up to the user to make sure that the correct top-level input database is passed to the constructor).</li></ul>
<p>
<ul>
<li>The numbering for the boundary conditions begins at 1.</li></ul>
<p>
<ul>
<li>The boundary condition types are as follows:<ul>
<li>NONE: 0</li><li>HOMOEGENEOUS_NEUMANN: 1</li><li>LINEAR_EXTRAPOLATION: 2</li><li>SIGNED_LINEAR_EXTRAPOLATION: 3</li><li>ANTI_PERIODIC: 4</li></ul>
</li></ul>
<p>
By default, no boundary conditions are imposed at any non-periodic boundary of the computational domain.<p>
<ul>
<li>Non-periodic boundary conditions MAY be imposed at boundaries that are specified to be periodic directions for the GridGeometry object associated with the PatchHierarchy set in the constructor. The non-periodic boundary conditions will override the periodic boundary conditions.</li></ul>
<p>
<ul>
<li>In order to use custom boundary conditions at a particular boundary location, the boundary condition type for that boundary location MUST be set to NONE. Otherwise, the boundary condition will be overwritten by specified boundary condition type.</li></ul>
<p>
<ul>
<li>When using a custom level set function integrator, all input parameters are ignored.</li></ul>
<p>
<ul>
<li>The descriptions of the input parameters for the LevelSetGriddingAlgorithm were taken almost verbatim from the class descriptions of the SAMRAI::mesh::GriddingAlgorithm, SAMRAI::mesh::StandardTagAndInitialize, and SAMRAI::mesh::TagAndInitializeStrategy classes in the files GriddingAlgorithm.h, StandardTagAndInitialize.h, and TagAndInitializeStrategy.h. For more details about the input parameters, please consult the <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> documentation for these classes.</li></ul>
<p>
<ul>
<li>For a list and description of optional gridding algorithm input fields, see the documentation for the SAMRAI::mesh::GriddingAlgorithm class.</li></ul>
<p>
<ul>
<li>For a list and description of optional load balancer input fields, see the documentation for the SAMRAI::mesh::LoadBalancer class.</li></ul>
<p>
<h4>Sample Input File </h4>
<p>
<pre><div>
  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a>{</pre></div><p>
<pre><div>    <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> {
      start_time  = 0.0
      end_time    = 0.5</pre></div><p>
<pre><div>      cfl_number               = 0.5
      spatial_derivative_type  = "WENO"
      spatial_derivative_order = 5
      tvd_runge_kutta_order    = 3</pre></div><p>
<pre><div>      reinitialization_interval = 0
      reinitialization_max_iters = 20
      reinitialization_stop_dist = 0.2
      orthogonalization_interval = 0
      orthogonalization_max_iters = 20
      orthogonalization_stop_dist = 0.2</pre></div><p>
<pre><div>      lower_bc_phi_0 = 1, 1, 1 
      upper_bc_phi_0 = 1, 1, 1</pre></div><p>
<pre><div>      use_AMR = FALSE
      refinement_cutoff_value = 0.25
      tag_buffer = 2,2,2,2,2,2</pre></div><p>
<pre><div>      verbose = false</pre></div><p>
<pre><div>    } // end of <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> database</pre></div><p>
<pre><div>    <a class="el" href="classLSMLIB_1_1LevelSetMethodGriddingAlgorithm.html">LevelSetMethodGriddingAlgorithm</a> {
      max_levels = 4</pre></div><p>
<pre><div>      ratio_to_coarser {
         level_1            = 2, 2
         level_2            = 2, 2
         level_3            = 2, 2
      }</pre></div><p>
<pre><div>      largest_patch_size {
        level_0 = 50,50
        level_1 = 100,100
        // all finer levels will use same values as level_1...
      }</pre></div><p>
<pre><div>      tagging_method = "GRADIENT_DETECTOR","REFINE_BOXES"</pre></div><p>
<pre><div>      RefineBoxes {  
        level_0 = [(15,0),(29,14)]
        level_1 = [(65,10),(114,40)]
      }</pre></div><p>
<pre><div>      LoadBalancer {  
        // load balancer input parameters
      }</pre></div><p>
<pre><div>    } // end of <a class="el" href="classLSMLIB_1_1LevelSetMethodGriddingAlgorithm.html">LevelSetMethodGriddingAlgorithm</a> database</pre></div><p>
<pre><div>  } // end of <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a> database</pre></div><p>
<pre><div>  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  </pre></div> 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="z63_0" doxytag="LSMLIB::LevelSetMethodAlgorithm::LevelSetMethodAlgorithm" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a> </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; Database &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>lsm_algorithm_input_db</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>patch_hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classLSMLIB_1_1LevelSetMethodPatchStrategy.html">LevelSetMethodPatchStrategy</a>&lt; DIM &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>patch_strategy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LevelSetMethodVelocityFieldStrategy</a>&lt; DIM &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>velocity_field_strategy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>num_level_set_fcn_components</em> = 1, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>codimension</em> = 1, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const string &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>object_name</em> = "LevelSetMethodAlgorithm&lt; DIM &gt;"</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This constructor for <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a> creates a <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> object from the user-specified <a class="el" href="classLSMLIB_1_1LevelSetMethodPatchStrategy.html">LevelSetMethodPatchStrategy</a> and <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LevelSetMethodVelocityFieldStrategy</a> objects and the parameters in the input and restart databases. This <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> object manages the time integration of the level set functions.<p>
Arguments:<ul>
<li>lsm_algorithm_input_db (in): input database containing user-defined parameters for the <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a></li><li>patch_hierarchy (in): PatchHierarchy for computation</li><li>patch_strategy (in): <a class="el" href="classLSMLIB_1_1LevelSetMethodPatchStrategy.html">LevelSetMethodPatchStrategy</a></li><li>velocity_field_strategy (in): <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LevelSetMethodVelocityFieldStrategy</a></li><li>num_level_set_fcn_components (in): number of components of level set functions (default = 1)</li><li>codimension (in): codimension of problem (default = 1)</li><li>object_name (in): name for object (default = "LevelSetMethodAlgorithm") </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z63_1" doxytag="LSMLIB::LevelSetMethodAlgorithm::LevelSetMethodAlgorithm" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a> </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegratorStrategy.html">LevelSetFunctionIntegratorStrategy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>lsm_integrator_strategy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Pointer&lt; <a class="el" href="classLSMLIB_1_1LevelSetMethodGriddingStrategy.html">LevelSetMethodGriddingStrategy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>lsm_gridding_strategy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const string &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>object_name</em> = "LevelSetMethodAlgorithm&lt; DIM &gt;"</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This constructor for <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a> uses a user-specified concrete subclass of the <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegratorStrategy.html">LevelSetFunctionIntegratorStrategy</a> class to manage the time integration of the level set functions.<p>
Arguments:<ul>
<li>lsm_integrator_strategy (in): pointer to concrete subclass of the <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegratorStrategy.html">LevelSetFunctionIntegratorStrategy</a></li><li>lsm_gridding_strategy (in): pointer to concrete subclass of the <a class="el" href="classLSMLIB_1_1LevelSetMethodGriddingStrategy.html">LevelSetMethodGriddingStrategy</a></li><li>object_name (in): name for object </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z63_2" doxytag="LSMLIB::LevelSetMethodAlgorithm::~LevelSetMethodAlgorithm" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::~<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a> </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The destructor for <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a> does nothing.     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="z71_2" doxytag="LSMLIB::LevelSetMethodAlgorithm::advanceLevelSetFunctions" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual bool <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::advanceLevelSetFunctions </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const LSMLIB_REAL&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dt</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z71_2">advanceLevelSetFunctions()</a> advances the level set function phi (and psi for codimension-two problems) by the specified time increment, dt.<p>
Arguments:<ul>
<li>dt (in): time increment to advance the level set functions</li></ul>
<p>
Return value: true if patch hierarchy needs to be regridded after this time step; false otherwise.<p>
NOTES:<ul>
<li>AMR is NOT yet implemented, so <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z71_2">advanceLevelSetFunctions()</a> currently always returns false. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z71_1" doxytag="LSMLIB::LevelSetMethodAlgorithm::computeStableDt" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual LSMLIB_REAL <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::computeStableDt </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z71_1">computeStableDt()</a> computes the maximum allowable dt for the next time step of the level set functions.<p>
If the standard <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> is used, the maximum stable dt is computed using the algorithm:<p>
<pre><div>
   if (user_specified_dt &lt; LSMLIB_REAL_MAX)</pre></div><p>
<pre><div>     dt = user_specified_dt</pre></div><p>
<pre><div>   else</pre></div><p>
<pre><div>     dt = min{physics_dt, advection_dt, normal_vel_dt}
 </pre></div><p>
In this algorithm, the various dt values are as follows:<p>
<ul>
<li>user_specified_dt: arbitrarily specified by the user and computed on a patch-by-patch basis by the user-defined concrete subclass of <a class="el" href="classLSMLIB_1_1LevelSetMethodPatchStrategy.html">LevelSetMethodPatchStrategy</a></li></ul>
<p>
<ul>
<li>physics_dt: based on the physics that determines the velocity field and computed by the user-defined concrete subclass of <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LevelSetMethodVelocityFieldStrategy</a></li></ul>
<p>
<ul>
<li>advection_dt: computed (in this method if required) using the current external (vector) velocity field and the "CFL time step" equation:</li></ul>
<p>
dt * max{|u|/dx + |v|/dy + |w|/dz} = cfl_number<p>
See Osher &amp; Fedkiw, "Level Set Methods and Dynamic Implicit Surfaces"<p>
<ul>
<li>normal_vel_dt: computed (in this method if required) using current normal (scalar) velocity field and the "CFL time step" equation:</li></ul>
<p>
dt * max{|vel_n|*(|phi_x|/dx + |phi_y|/dy + |phi_z|/dz)} = cfl_number<p>
See Osher &amp; Fedkiw, "Level Set Methods and Dynamic Implicit Surfaces"<p>
Arguments: none<p>
Return value: maximum stable dt for next time step     </td>
  </tr>
</table>
<a class="anchor" name="z67_3" doxytag="LSMLIB::LevelSetMethodAlgorithm::endTimeReached" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual bool <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::endTimeReached </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z67_3">endTimeReached()</a> returns true if the end time for the integration has been reached; otherwise, it returns false.<p>
Arguments: none<p>
Return value: true if the current time is equal to or after the end time for the integration; false otherwise     </td>
  </tr>
</table>
<a class="anchor" name="z68_3" doxytag="LSMLIB::LevelSetMethodAlgorithm::getCFLNumber" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual LSMLIB_REAL <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::getCFLNumber </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z68_3">getCFLNumber()</a> returns CFL number used by the standard <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> object to compute a stable time step.<p>
Arguments: none<p>
Return value : CFL number     </td>
  </tr>
</table>
<a class="anchor" name="z65_2" doxytag="LSMLIB::LevelSetMethodAlgorithm::getControlVolumePatchDataHandle" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual int <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::getControlVolumePatchDataHandle </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z65_2">getControlVolumePatchDataHandle()</a> returns the patch data handle for the control volume.<p>
Arguments: none<p>
Return value: PatchData handle for control volume     </td>
  </tr>
</table>
<a class="anchor" name="z67_2" doxytag="LSMLIB::LevelSetMethodAlgorithm::getCurrentTime" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual LSMLIB_REAL <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::getCurrentTime </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z67_2">getCurrentTime()</a> returns the current simulation time.<p>
Arguments: none<p>
Return value : current time     </td>
  </tr>
</table>
<a class="anchor" name="z67_1" doxytag="LSMLIB::LevelSetMethodAlgorithm::getEndTime" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual LSMLIB_REAL <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::getEndTime </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z67_1">getEndTime()</a> returns the simulation end time.<p>
Arguments: none<p>
Return value : end time     </td>
  </tr>
</table>
<a class="anchor" name="z77_1" doxytag="LSMLIB::LevelSetMethodAlgorithm::getFieldExtensionAlgorithm" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual Pointer&lt; <a class="el" href="classLSMLIB_1_1FieldExtensionAlgorithm.html">FieldExtensionAlgorithm</a>&lt;DIM&gt; &gt; <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::getFieldExtensionAlgorithm </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname" nowrap> <em>field_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="namespaceLSMLIB.html#a5">LEVEL_SET_FCN_TYPE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>level_set_fcn</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="namespaceLSMLIB.html#a6">SPATIAL_DERIVATIVE_TYPE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_derivative_type</em> = UNKNOWN, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_derivative_order</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>tvd_runge_kutta_order</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>LSMLIB_REAL&nbsp;</td>
          <td class="mdname" nowrap> <em>cfl_number</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const LSMLIB_REAL&nbsp;</td>
          <td class="mdname" nowrap> <em>stop_distance</em> = 0.0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>max_iterations</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const LSMLIB_REAL&nbsp;</td>
          <td class="mdname" nowrap> <em>iteration_stop_tolerance</em> = 0.0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bool&nbsp;</td>
          <td class="mdname" nowrap> <em>verbose_mode</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const string &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>object_name</em> = "FieldExtensionAlgorithm"</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z77_0">getFieldExtensionAlgorithm()</a> creates a <a class="el" href="classLSMLIB_1_1FieldExtensionAlgorithm.html">FieldExtensionAlgorithm</a> object that can be used to extend the specified field off of the zero level set of the specified level set function (PHI or PSI). The PatchHierarchy used for by the <a class="el" href="classLSMLIB_1_1FieldExtensionAlgorithm.html">FieldExtensionAlgorithm</a> is the same as the one that is used by the <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a>. This version of <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z77_0">getFieldExtensionAlgorithm()</a> takes the parameters for the field extension calculation as explicit arguments.<p>
Arguments:<ul>
<li>field_handle (in): PatchData handle for field to extend off of the interface</li><li>level_set_fcn (in): the level set function to use in field extension calculation</li><li>spatial_derivative_type (in): type of spatial derivative calculation (default = spatial derivative type used for evolving level set function)</li><li>spatial_derivative_order (in): order of spatial derivative (default = spatial derivative order used for evolving level set function)</li><li>tvd_runge_kutta_order (in): order of TVD Runge-Kutta integration (default = TVD Runge-Kutta order used for evolving level set function)</li><li>cfl_number (in): CFL number used to compute dt (default = CFL number used for evolving level set function)</li><li>stop_distance (in): approximate stopping criterion for evolution of field extension equation. Field extension stops after the information from the zero level set has propagated by approximately the specified distance. (default = 0.0)</li><li>max_iterations (in): maximum number of time steps to take during the field extension process (default = 0)</li><li>iteration_stop_tolerance (in): stopping criterion for termination of evolution of field extension equation. Field extension stops when the max norm of the change in the extension field drops below the specified tolerance. (default = 0.0)</li><li>verbose_mode (in): flag to activate/deactivate verbose-mode (default = false)</li><li>object_name (in): string name for object (default = "FieldExtensionAlgorithm")</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z77_0">getFieldExtensionAlgorithm()</a> may only be used when using the standard <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a>.</li></ul>
<p>
<ul>
<li><a class="el" href="classLSMLIB_1_1FieldExtensionAlgorithm.html">FieldExtensionAlgorithm</a> objects created using this method do NOT need to have the <a class="el" href="classLSMLIB_1_1FieldExtensionAlgorithm.html#z17_0">FieldExtensionAlgorithm::resetHierarchyConfiguration()</a> method invoked when the hierarchy configuration changes. The <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a> automatically handles the reset when <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z75_0">LevelSetMethodAlgorithm::resetHierarchyConfiguration()</a> is invoked. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z77_0" doxytag="LSMLIB::LevelSetMethodAlgorithm::getFieldExtensionAlgorithm" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual Pointer&lt; <a class="el" href="classLSMLIB_1_1FieldExtensionAlgorithm.html">FieldExtensionAlgorithm</a>&lt;DIM&gt; &gt; <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::getFieldExtensionAlgorithm </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; Database &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>input_db</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>field_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="namespaceLSMLIB.html#a5">LEVEL_SET_FCN_TYPE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>level_set_fcn</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const string &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>object_name</em> = "FieldExtensionAlgorithm"</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z77_0">getFieldExtensionAlgorithm()</a> creates a <a class="el" href="classLSMLIB_1_1FieldExtensionAlgorithm.html">FieldExtensionAlgorithm</a> object that can be used to extend the specified field off of the zero level set of the specified level set function (PHI or PSI). The PatchHierarchy used for by the <a class="el" href="classLSMLIB_1_1FieldExtensionAlgorithm.html">FieldExtensionAlgorithm</a> is the same as the one that is used by the <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a>. This version of <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z77_0">getFieldExtensionAlgorithm()</a> read the parameters for the field extension calculation from specified input database.<p>
Arguments:<ul>
<li>input_db (in): input database containing user-defined parameters</li><li>field_handle (in): PatchData handle for field to extend off of the interface</li><li>level_set_fcn (in): the level set function to use in field extension calculation</li><li>verbose_mode (in): flag to activate/deactivate verbose-mode (default = false)</li><li>object_name (in): string name for object (default = "FieldExtensionAlgorithm")</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li><a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z77_0">getFieldExtensionAlgorithm()</a> may only be used when using the standard <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a>.</li></ul>
<p>
<ul>
<li><a class="el" href="classLSMLIB_1_1FieldExtensionAlgorithm.html">FieldExtensionAlgorithm</a> objects created using this method do NOT need to have the <a class="el" href="classLSMLIB_1_1FieldExtensionAlgorithm.html#z17_0">FieldExtensionAlgorithm::resetHierarchyConfiguration()</a> method invoked when the hierarchy configuration changes. The <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a> automatically handles the reset when <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z75_0">LevelSetMethodAlgorithm::resetHierarchyConfiguration()</a> is invoked. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z73_3" doxytag="LSMLIB::LevelSetMethodAlgorithm::getOrthogonalizationInterval" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual int <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::getOrthogonalizationInterval </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z73_3">getOrthogonalizationInterval()</a> should return the number of time steps between orthogonalizations of the level set functions.<p>
Arguments: none<p>
Return value: orthogonalization interval     </td>
  </tr>
</table>
<a class="anchor" name="z65_0" doxytag="LSMLIB::LevelSetMethodAlgorithm::getPhiPatchDataHandle" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual int <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::getPhiPatchDataHandle </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z65_0">getPhiPatchDataHandle()</a> returns the patch data handle for phi.<p>
Arguments: none<p>
Return value: PatchData handle for phi<p>
NOTES:<ul>
<li>When the standard constructor for the <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a> is used, the PatchData for phi associated with the returned PatchData handle has the number of ghostcells required for the spatial derivative type and order specified when the <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a> object was constructed. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z65_1" doxytag="LSMLIB::LevelSetMethodAlgorithm::getPsiPatchDataHandle" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual int <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::getPsiPatchDataHandle </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z65_1">getPsiPatchDataHandle()</a> returns the patch data handle for psi.<p>
Arguments: none<p>
Return value: PatchData handle for psi<p>
NOTES:<ul>
<li>When the standard constructor for the <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a> is used, the PatchData for psi associated with the returned PatchData handle has the number of ghostcells required for the spatial derivative type and order specified when the <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a> object was constructed. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z73_0" doxytag="LSMLIB::LevelSetMethodAlgorithm::getReinitializationInterval" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual int <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::getReinitializationInterval </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z73_0">getReinitializationInterval()</a> should return the number of time steps between reinitializations of the level set functions.<p>
Arguments: none<p>
Return value: reinitialization interval     </td>
  </tr>
</table>
<a class="anchor" name="z68_1" doxytag="LSMLIB::LevelSetMethodAlgorithm::getSpatialDerivativeOrder" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual int <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::getSpatialDerivativeOrder </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z68_1">getSpatialDerivativeOrder()</a> returns order of the spatial derivative discretization used by the standard <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> object.<p>
Arguments: none<p>
Return value : spatial derivative order     </td>
  </tr>
</table>
<a class="anchor" name="z68_0" doxytag="LSMLIB::LevelSetMethodAlgorithm::getSpatialDerivativeType" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual int <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::getSpatialDerivativeType </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z68_0">getSpatialDerivativeType()</a> returns type of spatial derivative discretization used by the standard <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> object.<p>
Arguments: none<p>
Return value : spatial derivative type<p>
NOTES:<ul>
<li>Meaning of return values: 0 = ENO, 1 = WENO. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z67_0" doxytag="LSMLIB::LevelSetMethodAlgorithm::getStartTime" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual LSMLIB_REAL <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::getStartTime </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z67_0">getStartTime()</a> returns the simulation start time.<p>
Arguments: none<p>
Return value : start time     </td>
  </tr>
</table>
<a class="anchor" name="z68_2" doxytag="LSMLIB::LevelSetMethodAlgorithm::getTVDRungeKuttaOrder" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual int <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::getTVDRungeKuttaOrder </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z68_2">getTVDRungeKuttaOrder()</a> returns order of the TVD Runge-Kutta integration scheme used by the standard <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> object.<p>
Arguments: none<p>
Return value : TVD Runge-Kutta order     </td>
  </tr>
</table>
<a class="anchor" name="z71_0" doxytag="LSMLIB::LevelSetMethodAlgorithm::initializeLevelSetMethodCalculation" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::initializeLevelSetMethodCalculation </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z71_0">initializeLevelSetMethodCalculation()</a> initializes the data on the PatchHierarchy in preparation for a level set method calculation.<p>
Arguments: none<p>
Return value: none     </td>
  </tr>
</table>
<a class="anchor" name="z67_4" doxytag="LSMLIB::LevelSetMethodAlgorithm::numIntegrationStepsTaken" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual int <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::numIntegrationStepsTaken </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z67_4">numIntegrationStepsTaken()</a> returns the number of integration steps that have been taken during the level set method calculation.<p>
Arguments: none<p>
Return value : current integration step count     </td>
  </tr>
</table>
<a class="anchor" name="z73_5" doxytag="LSMLIB::LevelSetMethodAlgorithm::orthogonalizeLevelSetFunctions" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::orthogonalizeLevelSetFunctions </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="namespaceLSMLIB.html#a5">LEVEL_SET_FCN_TYPE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>level_set_fcn</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>max_reinit_iterations</em> = -1, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>max_ortho_iterations</em> = -1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z73_5">orthogonalizeLevelSetFunctions()</a> reinitializes the level set functions phi and psi and evolves them so that they have orthogonal gradients. This goal is achieved by solving the orthogonalization equation:<p>
phi_t + sgn(psi) * ( grad(psi)/|grad(psi)| ) dot grad(phi) = 0<p>
This Hamilton-Jacobi equation is advanced in time towards steady-state using the same TVD Runge-Kutta method selected to advance the level set equation. The number of steps taken is a function of the user-specified input parameters: orthogonalization_stop_dist and orthogonalization_max_iters. grad(phi) is computed using the same numerical discretization used to calculate the spatial derivatives when advancing the level set equation. grad(psi) is computed using by taking the average of the forward and backward spatial derivatives. grad(phi) is computed via a simple upwinding scheme that treats grad(psi) as the velocity.<p>
Arguments:<ul>
<li>level_set_fcn (in): level set function (i.e. PHI or PSI) to evolve to orthogonalize grad(phi) and grad(psi)</li><li>max_reinit_iterations (in): maximum number of iterations to use for reinitialization. Set max_iterations to -1 to use the value specified in the input file. (default = -1)</li><li>max_ortho_iterations (in): maximum number of iterations to use for orthogonalization. Set max_iterations to -1 to use the value specified in the input file. (default = -1)</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>This method is ONLY used for codimension-two problems. For codimension-one problems, this method is never invoked.</li></ul>
<p>
<ul>
<li>If max_reinit_iterations is set to a non-negative value, it overrides ALL of the reinitialization stopping criteria specified in the input file.</li></ul>
<p>
<ul>
<li>If max_ortho_iterations is set to a non-negative value, it overrides ALL of the orthogonalization stopping criteria specified in the input file. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z67_5" doxytag="LSMLIB::LevelSetMethodAlgorithm::printClassData" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::printClassData </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ostream &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>os</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z67_5">printClassData()</a> prints the values of the data members for an instance of the <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a> class.<p>
Arguments:<ul>
<li>os (in): output stream to write object information</li></ul>
<p>
Return value: none     </td>
  </tr>
</table>
<a class="anchor" name="z75_1" doxytag="LSMLIB::LevelSetMethodAlgorithm::regridPatchHierarchy" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::regridPatchHierarchy </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z75_1">regridPatchHierarchy()</a> regrids the entire PatchHierarchy and reinitializes the data on the PatchHierarchy using interpolation and averaging, as necessary.<p>
Arguments: none<p>
Return value: none     </td>
  </tr>
</table>
<a class="anchor" name="z73_2" doxytag="LSMLIB::LevelSetMethodAlgorithm::reinitializeLevelSetFunctions" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::reinitializeLevelSetFunctions </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="namespaceLSMLIB.html#a5">LEVEL_SET_FCN_TYPE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>level_set_fcn</em> = LSMLIB::PHI, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>max_iterations</em> = -1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
reinitializeLevelSetFuntions() reinitializes the level set functions to be distance functions using the reinitialization equation:<p>
phi_t + sgn(phi) * ( |grad(phi)| - 1 ) = 0<p>
This Hamilton-Jacobi equation is advanced in time towards steady-state using the same TVD Runge-Kutta method selected to advance the level set equation. The number of steps taken is a function of the user-specified input parameters: reinitialization_stop_dist and reinitialization_max_iters. grad(phi) is computed using the same numerical discretization used to calculate the spatial derivatives when advancing the level set equation. A Godunov scheme is used to select whether the appropriate spatial derivative approximation for each component of grad(phi).<p>
Arguments:<ul>
<li>level_set_fcn (in): level set function (i.e. PHI or PSI) to reinitialize (default = PHI)</li><li>max_iterations (in): maximum number of iterations to use for reinitialization. Set max_iterations to -1 to use the value specified in the input file. (default = -1)</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>If max_iterations is set to a non-negative value, it overrides ALL of the stopping criteria specified in the input file. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z75_0" doxytag="LSMLIB::LevelSetMethodAlgorithm::resetHierarchyConfiguration" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::resetHierarchyConfiguration </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>coarsest_level</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>finest_level</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z75_0">resetHierarchyConfiguration()</a> resets the configuration of the calculation and communication objects to be consistent with the specified PatchHierarchy.<p>
Arguments:<ul>
<li>hierarchy (in): PatchHierarchy to reconfigure</li><li>coarsest_level (in): coarsest level in hierarchy to reconfigure</li><li>finest_level (in): finest level in hierarchy to reconfigure</li></ul>
<p>
Return value: none     </td>
  </tr>
</table>
<a class="anchor" name="z69_0" doxytag="LSMLIB::LevelSetMethodAlgorithm::setBoundaryConditions" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::setBoundaryConditions </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lower_bc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>upper_bc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="namespaceLSMLIB.html#a5">LEVEL_SET_FCN_TYPE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>level_set_fcn</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>component</em> = -1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z69_0">setBoundaryConditions()</a> sets the boundary conditions to impose at the outer faces of the computational domain for the specified components of the vector level set function. If no component is specified, then ALL components of a vector level set function will be set to have the same boundary conditions imposed.<p>
Arguments:<ul>
<li>lower_bc (in): vector of integers specifying the type of boundary conditions to impose on the lower face of the computational domain in each coordinate direction. The i-th entry should contain the type of boundary condition to impose at the lower boundary in the i-th coordinate direction. See NOTES for boundary condition types. For information about the boundary condition types, see documentation of the <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> class.</li><li>upper_bc (in): vector of integers specifying the type of boundary conditions to impose on the upper face of the computational domain in each coordinate direction. The i-th entry should contain the type of boundary condition to impose at the upper boundary in the i-th coordinate direction. See NOTES for boundary condition types. For information about the boundary condition types, see documentation of the <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> class.</li><li>level_set_fcn (in): level set function (i.e. PHI or PSI) for which to set boundary conditions</li><li>component (in): component of level set function for which to set boundary conditions (default = -1)</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>The boundary condition types are as follows: NONE, HOMOEGENEOUS_NEUMANN, LINEAR_EXTRAPOLATION, SIGNED_LINEAR_EXTRAPOLATION, ANTI_PERIODIC</li></ul>
<p>
If anti-periodic boundary conditions are imposed in the i-th coordinate direction, then the i-th entry of lower_bc and upper_bc MUST both be set to ANTI_PERIODIC.<p>
For more information about the various boundary conditions, see the documentation for the <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> class.<p>
<ul>
<li>Anti-periodic boundary conditions are only imposed for those directions that are specified by bc AND that are periodic directions for the GridGeometry object associated with the PatchHierarchy set in the constructor. If a direction is specified to be anti-periodic by the bc variable but is not a periodic direction for the GridGeometry object, then that direction is NOT treated as an anti-periodic direction.</li></ul>
<p>
<ul>
<li>If component is set to a negative number, than ALL components of the level set function will be set to have the specified homogeneous Neumann boundaries. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z73_4" doxytag="LSMLIB::LevelSetMethodAlgorithm::setOrthogonalizationInterval" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::setOrthogonalizationInterval </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>interval</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z73_4">setOrthogonalizationInterval()</a> should set the number of time steps between orthogonalizations of the level set functions.<p>
Arguments:<ul>
<li>interval (in): number of time steps to take between orthogonalizations of the level set functions</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>To disable orthogonalization, set interval to zero. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z73_1" doxytag="LSMLIB::LevelSetMethodAlgorithm::setReinitializationInterval" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::setReinitializationInterval </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>interval</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#z73_1">setReinitializationInterval()</a> should set the number of time steps between reinitializations of the level set functions.<p>
Arguments:<ul>
<li>interval (in): number of time steps to take between reinitializations of the level set functions</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>To disable reinitialization, set interval to zero. </li></ul>
    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="p9" doxytag="LSMLIB::LevelSetMethodAlgorithm::d_cfl_number" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> LSMLIB_REAL <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#p9">d_cfl_number</a><code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p3" doxytag="LSMLIB::LevelSetMethodAlgorithm::d_field_extension_alg_list" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Array&lt; Pointer&lt; <a class="el" href="classLSMLIB_1_1FieldExtensionAlgorithm.html">FieldExtensionAlgorithm</a>&lt;DIM&gt; &gt; &gt; <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#p3">d_field_extension_alg_list</a><code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p2" doxytag="LSMLIB::LevelSetMethodAlgorithm::d_lsm_gridding_strategy" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Pointer&lt; <a class="el" href="classLSMLIB_1_1LevelSetMethodGriddingStrategy.html">LevelSetMethodGriddingStrategy</a>&lt;DIM&gt; &gt; <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#p2">d_lsm_gridding_strategy</a><code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p1" doxytag="LSMLIB::LevelSetMethodAlgorithm::d_lsm_integrator_strategy" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Pointer&lt; <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegratorStrategy.html">LevelSetFunctionIntegratorStrategy</a>&lt;DIM&gt; &gt; <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#p1">d_lsm_integrator_strategy</a><code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p0" doxytag="LSMLIB::LevelSetMethodAlgorithm::d_object_name" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> string <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#p0">d_object_name</a><code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p4" doxytag="LSMLIB::LevelSetMethodAlgorithm::d_patch_hierarchy" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Pointer&lt; PatchHierarchy&lt;DIM&gt; &gt; <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#p4">d_patch_hierarchy</a><code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p7" doxytag="LSMLIB::LevelSetMethodAlgorithm::d_spatial_derivative_order" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#p7">d_spatial_derivative_order</a><code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p6" doxytag="LSMLIB::LevelSetMethodAlgorithm::d_spatial_derivative_type" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="namespaceLSMLIB.html#a6">SPATIAL_DERIVATIVE_TYPE</a> <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#p6">d_spatial_derivative_type</a><code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p8" doxytag="LSMLIB::LevelSetMethodAlgorithm::d_tvd_runge_kutta_order" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#p8">d_tvd_runge_kutta_order</a><code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p5" doxytag="LSMLIB::LevelSetMethodAlgorithm::d_using_standard_level_set_fcn_integrator" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bool <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LSMLIB::LevelSetMethodAlgorithm</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html#p5">d_using_standard_level_set_fcn_integrator</a><code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="LevelSetMethodAlgorithm_8h-source.html">LevelSetMethodAlgorithm.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Sun May 3 19:14:23 2009 for LSMLIB by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
