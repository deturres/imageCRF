<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LSMLIB:  TemplateLSMLIB::LevelSetMethodPatchStrategy&lt; DIM &gt; class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>LSMLIB::LevelSetMethodPatchStrategy&lt; DIM &gt; Class Template Reference</h1>The <a class="el" href="classLSMLIB_1_1LevelSetMethodPatchStrategy.html">LevelSetMethodPatchStrategy</a> class defines the interface for single patch, problem specific numerical routines.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="LevelSetMethodPatchStrategy_8h-source.html">LevelSetMethodPatchStrategy.h</a>&gt;</code>
<p>
<a href="classLSMLIB_1_1LevelSetMethodPatchStrategy-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods for setting initial and boundary conditions</div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodPatchStrategy.html#z95_0">initializeLevelSetFunctionsOnPatch</a> (Patch&lt; DIM &gt; &amp;patch, const  LSMLIB_REAL time, const  int phi_handle, const  int psi_handle)=0</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodPatchStrategy.html#z95_1">setLevelSetFunctionBoundaryConditions</a> (Patch&lt; DIM &gt; &amp;patch, const  LSMLIB_REAL fill_time, const  int phi_handle, const  int psi_handle, const  IntVector&lt; DIM &gt; &amp;ghost_width_to_fill)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Methods related to time integration</div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual LSMLIB_REAL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodPatchStrategy.html#z97_0">computeStableDtOnPatch</a> (Patch&lt; DIM &gt; &amp;patch, <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a>&lt; DIM &gt; *lsm_integrator, <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LevelSetMethodVelocityFieldStrategy</a>&lt; DIM &gt; *velocity_field_strategy)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Destructors</div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodPatchStrategy.html#z99_0">~LevelSetMethodPatchStrategy</a> ()</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int DIM&gt;<br>
 class LSMLIB::LevelSetMethodPatchStrategy&lt; DIM &gt;</h3>

The <a class="el" href="classLSMLIB_1_1LevelSetMethodPatchStrategy.html">LevelSetMethodPatchStrategy</a> class defines the interface for single patch, problem specific numerical routines. 
<p>
In particular, it defines interfaces for initialization of data on a patch, setting the boundary conditions for the level set functions, and computing a stable time step size for the next TVD Runge-Kutta time step.<p>
It is worth mentioning that the dt returned by the <a class="el" href="classLSMLIB_1_1LevelSetMethodPatchStrategy.html#z97_0">computeStableDtOnPatch()</a> method is intended to give the user the flexibility to specify a time step size in a completely arbitrary manner that is appropriate for his/her specific problem.<p>
<h3>NOTES: </h3>
<p>
<ul>
<li>In order to use the <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> class, a user MUST implement a concrete subclass of this ``strategy'' class. </li></ul>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="z99_0" doxytag="LSMLIB::LevelSetMethodPatchStrategy::~LevelSetMethodPatchStrategy" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classLSMLIB_1_1LevelSetMethodPatchStrategy.html">LSMLIB::LevelSetMethodPatchStrategy</a>&lt; DIM &gt;::~<a class="el" href="classLSMLIB_1_1LevelSetMethodPatchStrategy.html">LevelSetMethodPatchStrategy</a> </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructor does nothing but must be declared virtual so that concrete subclasses are properly destroyed.     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="z97_0" doxytag="LSMLIB::LevelSetMethodPatchStrategy::computeStableDtOnPatch" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual LSMLIB_REAL <a class="el" href="classLSMLIB_1_1LevelSetMethodPatchStrategy.html">LSMLIB::LevelSetMethodPatchStrategy</a>&lt; DIM &gt;::computeStableDtOnPatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Patch&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>patch</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a>&lt; DIM &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>lsm_integrator</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LevelSetMethodVelocityFieldStrategy</a>&lt; DIM &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>velocity_field_strategy</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodPatchStrategy.html#z97_0">computeStableDtOnPatch()</a> returns a user-specified stable dt on a patch.<p>
Arguments:<ul>
<li>patch (in): Patch on which to compute a stable time step size</li><li>lsm_integrator (in): pointer to <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a></li><li>velocity_field_strategy (in): pointer to <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LevelSetMethodVelocityFieldStrategy</a></li></ul>
<p>
Return value: user-specified time step dt<p>
NOTES:<ul>
<li>The dt returned by this method need not be related to the current values of the level set functions or velocity field. This method is intended to allow the user to specify a completely arbitrary time step size.</li></ul>
<p>
<ul>
<li>If this method returns any value smaller than LSMLIB_REAL_MAX, the <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> will ignore the internally computed maximum stable dt and the stable dt returned by the user implemented subclass of <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LevelSetMethodVelocityFieldStrategy</a>.</li></ul>
<p>
<ul>
<li>The pointer to the <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LevelSetMethodVelocityFieldStrategy</a> object is provided in case the stable dt calculation requires information about the velocity field.</li></ul>
<p>
<ul>
<li>It is virtual with an default implementation here (rather than pure virtual) so that users are not required to provide an implementation. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z95_0" doxytag="LSMLIB::LevelSetMethodPatchStrategy::initializeLevelSetFunctionsOnPatch" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void <a class="el" href="classLSMLIB_1_1LevelSetMethodPatchStrategy.html">LSMLIB::LevelSetMethodPatchStrategy</a>&lt; DIM &gt;::initializeLevelSetFunctionsOnPatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Patch&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>patch</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const LSMLIB_REAL&nbsp;</td>
          <td class="mdname" nowrap> <em>time</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>psi_handle</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodPatchStrategy.html#z95_0">initializeLevelSetFunctionsOnPatch()</a> initializes the level set functions on a single patch.<p>
Arguments:<ul>
<li>patch (in): Patch on which to initialize level set functions</li><li>current_time (in): current time</li><li>phi_handle (in): PatchData handle for phi</li><li>psi_handle (in): PatchData handle for psi</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>For codimension-one problems, psi_handle is NOT guaranteed to be set to a valid PatchData handle, so it should be ignored in the user-defined version of this method.</li></ul>
<p>
<ul>
<li>This is a pure abstract method that the user MUST override in order to use the <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> class. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z95_1" doxytag="LSMLIB::LevelSetMethodPatchStrategy::setLevelSetFunctionBoundaryConditions" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void <a class="el" href="classLSMLIB_1_1LevelSetMethodPatchStrategy.html">LSMLIB::LevelSetMethodPatchStrategy</a>&lt; DIM &gt;::setLevelSetFunctionBoundaryConditions </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Patch&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>patch</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const LSMLIB_REAL&nbsp;</td>
          <td class="mdname" nowrap> <em>fill_time</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>psi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const IntVector&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>ghost_width_to_fill</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodPatchStrategy.html#z95_1">setLevelSetFunctionBoundaryConditions()</a> can be used to set the data in ghost cells in user-defined ways in order to impose boundary conditions for the level set functions. The standard boundary conditions provided by <a class="el" href="classLSMLIB_1_1BoundaryConditionModule.html">BoundaryConditionModule</a> class (which can be managed by the <a class="el" href="classLSMLIB_1_1LevelSetMethodAlgorithm.html">LevelSetMethodAlgorithm</a> input file) are sufficient for most level set method calculations.<p>
Arguments:<ul>
<li>patch (in): Patch on which to set boundary conditions for the level set functions</li><li>fill_time (in): time at which boundary data are being filled</li><li>phi_handle (in): PatchData handle for phi</li><li>psi_handle (in): PatchData handle for psi</li><li>ghost_width_to_fill (in): width of ghost cells to fill</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>For codimension-one problems, psi_handle is NOT guaranteed to be set to a valid PatchData handle, so it should be ignored in the user-defined version of this method.</li></ul>
<p>
<ul>
<li>Because this method is called BEFORE the standard boundary conditions are imposed, the user MUST set the boundary condtion type to NONE for boundaries where custom boundary conditions are to be imposed. Otherwise, any ghost cells set by this method will be overwritten.</li></ul>
<p>
<ul>
<li>It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation. </li></ul>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="LevelSetMethodPatchStrategy_8h-source.html">LevelSetMethodPatchStrategy.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Sun May 3 19:14:23 2009 for LSMLIB by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
