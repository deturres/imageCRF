<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LSMLIB:  TemplateLSMLIB::LevelSetMethodToolbox&lt; DIM &gt; class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>LSMLIB::LevelSetMethodToolbox&lt; DIM &gt; Class Template Reference</h1><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LevelSetMethodToolbox</a> is a utility class that provides support for several basic level set method algorithms and computations.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="LevelSetMethodToolbox_8h-source.html">LevelSetMethodToolbox.h</a>&gt;</code>
<p>
<a href="classLSMLIB_1_1LevelSetMethodToolbox-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Type and constant definitions</div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z101_0">UNIT_NORMAL_TYPE</a> { <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z101_0w0">PHI_UPWIND</a> =  0, 
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z101_0w1">AVERAGE</a> =  1
 }</td></tr>

<tr><td colspan=2><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods for computing spatial derivatives</div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z103_0">computeUpwindSpatialDerivatives</a> (Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; hierarchy, const  <a class="el" href="namespaceLSMLIB.html#a6">SPATIAL_DERIVATIVE_TYPE</a> spatial_derivative_type, const  int spatial_derivative_order, const  int grad_phi_handle, const  int phi_handle, const  int upwind_function_handle, const  int phi_component=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z103_1">computePlusAndMinusSpatialDerivatives</a> (Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; hierarchy, const  <a class="el" href="namespaceLSMLIB.html#a6">SPATIAL_DERIVATIVE_TYPE</a> spatial_derivative_type, const  int spatial_derivative_order, const  int grad_phi_plus_handle, const  int grad_phi_minus_handle, const  int phi_handle, const  int phi_component=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z103_2">computeCentralSpatialDerivatives</a> (Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; hierarchy, const  int spatial_derivative_order, const  int grad_phi_handle, const  int phi_handle, const  int phi_component=0)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Methods for time integration using TVD Runge-Kutta methods</div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z105_0">TVDRK1Step</a> (Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; hierarchy, const  int u_next_handle, const  int u_cur_handle, const  int rhs_handle, const  LSMLIB_REAL dt, const  int u_next_component=0, const  int u_cur_component=0, const  int rhs_component=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z105_1">TVDRK2Stage1</a> (Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; hierarchy, const  int u_stage1_handle, const  int u_cur_handle, const  int rhs_handle, const  LSMLIB_REAL dt, const  int u_stage1_component=0, const  int u_cur_component=0, const  int rhs_component=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z105_2">TVDRK2Stage2</a> (Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; hierarchy, const  int u_next_handle, const  int u_stage1_handle, const  int u_cur_handle, const  int rhs_handle, const  LSMLIB_REAL dt, const  int u_next_component=0, const  int u_stage1_component=0, const  int u_cur_component=0, const  int rhs_component=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z105_3">TVDRK3Stage1</a> (Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; hierarchy, const  int u_stage1_handle, const  int u_cur_handle, const  int rhs_handle, const  LSMLIB_REAL dt, const  int u_stage1_component=0, const  int u_cur_component=0, const  int rhs_component=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z105_4">TVDRK3Stage2</a> (Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; hierarchy, const  int u_stage2_handle, const  int u_stage1_handle, const  int u_cur_handle, const  int rhs_handle, const  LSMLIB_REAL dt, const  int u_stage2_component=0, const  int u_stage1_component=0, const  int u_cur_component=0, const  int rhs_component=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z105_5">TVDRK3Stage3</a> (Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; hierarchy, const  int u_next_handle, const  int u_stage2_handle, const  int u_cur_handle, const  int rhs_handle, const  LSMLIB_REAL dt, const  int u_next_component=0, const  int u_stage2_component=0, const  int u_cur_component=0, const  int rhs_component=0)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Methods for based on the Fast Marching Method</div></td></tr>
<tr><td colspan="2"><div class="groupText">Used to computing distance functions and extension fields using the Fast Marching Method. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z107_0">computeDistanceFunctionUsingFMM</a> (Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; hierarchy, const  int spatial_derivative_order, const  int distance_function_handle, const  int phi_handle, const  int distance_function_component=0, const  int phi_component=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z107_1">computeExtensionFieldsUsingFMM</a> (Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; hierarchy, const  int spatial_derivative_order, const  vector&lt; int &gt; &amp;extension_field_handles, const  int distance_function_handle, const  vector&lt; int &gt; &amp;source_field_handles, const  int phi_handle, const  int extension_field_component=0, const  int distance_function_component=0, const  int source_field_component=0, const  int phi_component=0)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Methods for computing geometric quantities</div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z109_0">computeUnitNormalVectorFromPhi</a> (Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; patch_hierarchy, <a class="el" href="namespaceLSMLIB.html#a6">SPATIAL_DERIVATIVE_TYPE</a> spatial_derivative_type, const  int spatial_derivative_order, const  int normal_vector_handle, const  int phi_handle, const  <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z101_0">UNIT_NORMAL_TYPE</a> unit_normal_type, const  int phi_component=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z109_1">computeSignedUnitNormalVectorFromPhi</a> (Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; patch_hierarchy, <a class="el" href="namespaceLSMLIB.html#a6">SPATIAL_DERIVATIVE_TYPE</a> spatial_derivative_type, const  int spatial_derivative_order, const  int normal_vector_handle, const  int phi_handle, const  <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z101_0">UNIT_NORMAL_TYPE</a> unit_normal_type, const  int phi_component=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z109_2">computeUnitNormalVectorFromGradPhi</a> (Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; patch_hierarchy, const  int normal_vector_handle, const  int grad_phi_handle)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z109_3">computeSignedUnitNormalVectorFromGradPhi</a> (Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; patch_hierarchy, const  int normal_vector_handle, const  int grad_phi_handle, const  int phi_handle, const  int phi_component=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>LSMLIB_REAL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z109_4">computeVolumeOfRegionDefinedByZeroLevelSet</a> (Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; patch_hierarchy, const  int phi_handle, const  int control_volume_handle, const  int region_indicator, const  int phi_component=0, const  int heaviside_width=3)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>LSMLIB_REAL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z109_5">computeVolumeOfZeroLevelSet</a> (Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; patch_hierarchy, const  int phi_handle, const  int grad_phi_handle, const  int control_volume_handle, const  int phi_component=0, const  int delta_width=3)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>LSMLIB_REAL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z109_6">computeVolumeIntegral</a> (Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; patch_hierarchy, const  int F_handle, const  int phi_handle, const  int control_volume_handle, const  int region_integrator, const  int F_component=0, const  int phi_component=0, const  int heaviside_width=3)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>LSMLIB_REAL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z109_7">computeSurfaceIntegral</a> (Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; patch_hierarchy, const  int F_handle, const  int phi_handle, const  int grad_phi_handle, const  int control_volume_handle, const  int F_component=0, const  int phi_component=0, const  int delta_width=3)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Utility methods</div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>LSMLIB_REAL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z111_0">computeStableAdvectionDt</a> (Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; patch_hierarchy, const  int velocity_handle, const  int control_volume_handle, const  LSMLIB_REAL cfl_number)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>LSMLIB_REAL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z111_1">computeStableNormalVelocityDt</a> (Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; patch_hierarchy, const  int normal_velocity_handle, const  int grad_phi_plus_handle, const  int grad_phi_minus_handle, const  int control_volume_handle, const  LSMLIB_REAL cfl_number)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>LSMLIB_REAL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z111_2">maxNormOfDifference</a> (Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; hierarchy, const  int field1_handle, const  int field2_handle, const  int control_volume_handle, const  int field1_component=0, const  int field2_component=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z111_3">computeControlVolumes</a> (Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; patch_hierarchy, int control_volume_handle)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z111_4">copySAMRAIData</a> (Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; patch_hierarchy, const  int dst_handle, const  int src_handle, const  int dst_component=0, const  int src_component=0)</td></tr>

<tr><td colspan=2><br><h2>Static Protected Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Helper methods</div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z113_0">initializeComputeSpatialDerivativesParameters</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z113_1">initializeComputeUnitNormalParameters</a> ()</td></tr>

<tr><td colspan=2><br><h2>Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#t0">s_D1_one_ghostcell_handle</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#t1">s_D1_two_ghostcells_handle</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#t2">s_D2_two_ghostcells_handle</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#t3">s_D1_three_ghostcells_handle</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#t4">s_D2_three_ghostcells_handle</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#t5">s_D3_three_ghostcells_handle</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#t6">s_compute_normal_grad_phi_handle</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#t7">s_compute_normal_grad_phi_plus_handle</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#t8">s_compute_normal_grad_phi_minus_handle</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int DIM&gt;<br>
 class LSMLIB::LevelSetMethodToolbox&lt; DIM &gt;</h3>

<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LevelSetMethodToolbox</a> is a utility class that provides support for several basic level set method algorithms and computations. 
<p>
In particular, it includes functionality for the following:<p>
<ul>
<li>parallel computation of high-order ENO and WENO derivatives for arbitrary functions using the <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> framework to handle the data management issues;</li></ul>
<p>
<ul>
<li>standard first-, second-, and third-order TVD Runge-Kutta integration;</li></ul>
<p>
<ul>
<li>computation of distance functions and extension fields (e.g. velocity) using the fast-marching method algorithm;</li></ul>
<p>
<ul>
<li>computation of the unit normal vector (both on AND off of the zero level set);</li></ul>
<p>
<ul>
<li>computation of volume and surface integrals over regions defined by the zero level set;</li></ul>
<p>
<ul>
<li>computation of stable time step sizes for advection and normal velocity evolution;</li></ul>
<p>
<ul>
<li>computation of the max norm of the difference of two fields;</li></ul>
<p>
<ul>
<li>computation of control volumes for structured adaptive meshes; and</li></ul>
<p>
<ul>
<li>general data management/transfer procedures.</li></ul>
<p>
<h3>NOTES: </h3>
<p>
<ul>
<li>Since this class is a utility class, all methods are declared static (i.e. they are essentially C function calls). There is never be a need to instantiate an object of type <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LevelSetMethodToolbox</a>. Call the functions in this class as static functions using the syntax:</li></ul>
<p>
LevelSetMethodToolbox::function(...) 
<p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="z101_0" doxytag="LSMLIB::LevelSetMethodToolbox::UNIT_NORMAL_TYPE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z101_0">LSMLIB::LevelSetMethodToolbox::UNIT_NORMAL_TYPE</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enumerated type for the different methods of computing the spatial derivatives used to compute the unit normal vector.<p>
PHI_UPWIND: grad(phi) computed by selecting upwind direction based on sign of phi. If phi &gt; 0, upwind direction is direction where phi is smaller. If phi &lt; 0, upwind direction is direction where phi is larger.<p>
AVERAGE: grad(phi) computed by averaging plus and minus spatial derivatives <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="z101_0w0" doxytag="PHI_UPWIND" ></a>PHI_UPWIND</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="z101_0w1" doxytag="AVERAGE" ></a>AVERAGE</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="z103_2" doxytag="LSMLIB::LevelSetMethodToolbox::computeCentralSpatialDerivatives" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::computeCentralSpatialDerivatives </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_derivative_order</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>grad_phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_component</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z103_2">computeCentralSpatialDerivatives()</a> computes central approximations to the spatial derivatives with the specified order of accuracy.<p>
Arguments:<ul>
<li>hierarchy (in): Pointer to PatchHierarchy containing data</li><li>spatial_derivative_order (in): order of spatial derivative</li><li>grad_phi_handle (out): PatchData handle for grad(phi)</li><li>phi_handle (in): PatchData handle for phi</li><li>phi_component (in): component of phi for which to compute spatial derivatives (default = 0)</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>Support is only provided for the computation of the following order spatial derivatives: 2nd and 4th. If the user requests a 1st order derivative, the calculation automatically defaults 2nd order. If the user requests a 3rd order derivative, the the calculation automatically defaults 4th order.</li></ul>
<p>
<ul>
<li>It is the user's responsibility to ensure that the PatchData for phi is defined with a sufficent number of ghost cells to support calculation of the selected central derivative in the interior of the PatchData for grad(phi).</li></ul>
<p>
<ul>
<li>The 2nd order derivative is computed using the formula</li></ul>
<p>
<p class=formulaDsp>
<img class=formulaDsp alt="\[ \left( \frac{\partial \phi}{\partial x} \right)_i \approx \frac{ \phi_{i+1} - \phi_{i-1} }{ 2 dx } \]" src="form_29.png">
<p>
<p>
<ul>
<li>The 4th order derivative is computed using the formula</li></ul>
<p>
<p class=formulaDsp>
<img class=formulaDsp alt="\[ \left( \frac{\partial \phi}{\partial x} \right)_i \approx \frac{ -\phi_{i+2} + 8 \phi_{i+1} - 8 \phi_{i-1} + \phi_{i+2} } { 12 dx } \]" src="form_41.png">
<p>
     </td>
  </tr>
</table>
<a class="anchor" name="z111_3" doxytag="LSMLIB::LevelSetMethodToolbox::computeControlVolumes" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::computeControlVolumes </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>patch_hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>control_volume_handle</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z111_3">computeControlVolumes()</a> computes the control volumes for the cells in the specified PatchHierarchy.<p>
Arguments:<ul>
<li>control_volume_handle (out): PatchData handle where control volumes are to be stored</li><li>patch_hierarchy (in): PatchHierarchy on which to compute control volumes</li></ul>
<p>
Return value: none     </td>
  </tr>
</table>
<a class="anchor" name="z107_0" doxytag="LSMLIB::LevelSetMethodToolbox::computeDistanceFunctionUsingFMM" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::computeDistanceFunctionUsingFMM </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_derivative_order</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>distance_function_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>distance_function_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_component</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z107_0">computeDistanceFunctionUsingFMM()</a> uses the Fast-Marching Method algorithm to compute a distance function from the interface defined by the zero level set of the function.<p>
Arguments:<ul>
<li>hierarchy (in): Pointer to PatchHierarchy containing data</li><li>spatial_derivative_order (in): order of spatial derivative</li><li>distance_function_handle (out): PatchData handle for distance function</li><li>phi_handle (in): PatchData handle for level set function</li><li>distance_function_component(in): component of distance function data in which to store result (default = 0)</li><li>phi_component (in): component of phi for which to compute spatial derivatives (default = 0)</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z107_0">computeDistanceFunctionUsingFMM()</a> currently is only implemented in 2D. Support for 3D calculations will be available in a future release.</li></ul>
<p>
<ul>
<li><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z107_0">computeDistanceFunctionUsingFMM()</a> currently only supports first-order calculations. Support for second-order calculations will be available in a future release.</li></ul>
<p>
<ul>
<li><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z107_0">computeDistanceFunctionUsingFMM()</a> currently only supports calculation on a single patch.</li></ul>
<p>
<ul>
<li>The number of ghostcells for the PatchData of both the distance function and the original level set function are assumed to be the same. If they are not, an irrecoverable error is thrown.</li></ul>
<p>
<ul>
<li>Parallel computation of the distance function using the fast marching method is currently NOT supported</li></ul>
<p>
<ul>
<li>For more details on the algorithm used by computeDistanceFunctionsUsingFMM(), see "Level Set Methods and Fast Marching Methods" by J.A. Sethian and "The Fast Construction of Extension Velocities in Level Set Methods" by D. Adalsteinsson and J.A. Sethian (J. Comp. Phys, vol 148, p 2-22, 1999). </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z107_1" doxytag="LSMLIB::LevelSetMethodToolbox::computeExtensionFieldsUsingFMM" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::computeExtensionFieldsUsingFMM </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_derivative_order</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const vector&lt; int &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>extension_field_handles</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>distance_function_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const vector&lt; int &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>source_field_handles</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>extension_field_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>distance_function_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>source_field_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_component</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z107_1">computeExtensionFieldsUsingFMM()</a> uses the Fast-Marching Method to compute a distance function and extend auxilliary fields off of the interface defined by the zero level set of the function.<p>
Arguments:<ul>
<li>hierarchy (in): Pointer to PatchHierarchy containing data</li><li>spatial_derivative_order (in): order of spatial derivative</li><li>extension_field_handles (out): vector of PatchData handles for where extension fields are to be stored</li><li>distance_function_handle (out): PatchData handle for distance function</li><li>source_field_handles (in): vector of PatchData handles for source fields used to compute extension fields</li><li>phi_handle (in): PatchData handle for level set function</li><li>extension_field_component (in): component of extension field data in which to store computed extension fields (default = 0)</li><li>distance_function_component(in): component of distance function data in which to store computed distance function (default = 0)</li><li>source_field_component (in): component of source field data to use in computing extension fields (default = 0)</li><li>phi_component (in): component of phi for which to compute spatial derivatives (default = 0)</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z107_1">computeExtensionFieldsUsingFMM()</a> currently only supports first-order calculations. Support for second-order calculations will be available in a future release.</li></ul>
<p>
<ul>
<li><a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z107_1">computeExtensionFieldsUsingFMM()</a> currently only supports calculation on a single patch.</li></ul>
<p>
<ul>
<li>The number of ghostcells for the PatchData of the extension fields, the distance function, the source fields, and the original level set function are assumed to be the same. If they are not, an irrecoverable error is thrown.</li></ul>
<p>
<ul>
<li>Parallel computation of the distance function using the fast marching method is currently NOT supported</li></ul>
<p>
<ul>
<li>For more details on the algorithm used by <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z107_1">computeExtensionFieldsUsingFMM()</a>, see "Level Set Methods and Fast Marching Methods" by J.A. Sethian and "The Fast Construction of Extension Velocities in Level Set Methods" by D. Adalsteinsson and J.A. Sethian (J. Comp. Phys, vol 148, p 2-22, 1999). </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z103_1" doxytag="LSMLIB::LevelSetMethodToolbox::computePlusAndMinusSpatialDerivatives" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::computePlusAndMinusSpatialDerivatives </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="namespaceLSMLIB.html#a6">SPATIAL_DERIVATIVE_TYPE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_derivative_type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_derivative_order</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>grad_phi_plus_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>grad_phi_minus_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_component</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z103_1">computePlusAndMinusSpatialDerivatives()</a> computes the forward (plus) backward (minus) approximations to the spatial derivatives using the specified ENO/WENO scheme.<p>
Arguments:<ul>
<li>hierarchy (in): Pointer to PatchHierarchy containing data</li><li>spatial_derivative_type (in): type of spatial derivative calculation</li><li>spatial_derivative_order (in): order of spatial derivative</li><li>grad_phi_plus_handle (out): PatchData handle for forward approximation to grad(phi)</li><li>grad_phi_minus_handle (out): PatchData handle for backward approximation to grad(phi)</li><li>phi_handle (in): PatchData handle for phi</li><li>phi_component (in): component of phi for which to compute spatial derivatives (default = 0)</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>Support is only provided for the computation of the following spatial derivatives: ENO1 (i.e. 1st-order upwinding), ENO2, ENO3, and WENO5.</li></ul>
<p>
<ul>
<li>It is the user's responsibility to ensure that the PatchData for phi is defined with a sufficent number of ghost cells to support calculation of the selected ENO/WENO derivative in the interior of the PatchData for grad(phi).</li></ul>
<p>
<ul>
<li>For more details about the numerical discretizations used by <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z103_1">computePlusAndMinusSpatialDerivatives()</a>, see "Level Set Methods and Dynamic Implicit Surfaces" by Osher &amp; Fedkiw. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z109_3" doxytag="LSMLIB::LevelSetMethodToolbox::computeSignedUnitNormalVectorFromGradPhi" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::computeSignedUnitNormalVectorFromGradPhi </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>patch_hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>normal_vector_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>grad_phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_component</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z109_3">computeSignedUnitNormalVectorFromGradPhi()</a> computes the signed unit normal vector on AND off of the zero level set using the formula<p>
N = sgn(phi)*grad(phi)/|grad(phi)|<p>
given data for phi AND grad(phi). That is, the user is free to choose his/her own scheme for computing grad(phi).<p>
Arguments:<ul>
<li>patch_hierarchy (in): PatchHierarchy on which to compute stable normal velocity dt</li><li>normal_vector_handle (out): PatchData handle for normal vector</li><li>grad_phi_handle (in): PatchData handle for grad(phi)</li><li>phi_handle (in): PatchData handle for phi</li><li>phi_component (in): component of phi that was used to compute grad(phi) (default = 0)</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>There are no restrictions on the number of ghostcells for any of the data.</li></ul>
<p>
<ul>
<li>The following formula is used for the smoothed sgn function:</li></ul>
<p>
sgn(phi) = phi/sqrt( phi^2 + |grad(phi)|^2 * dx^2 )     </td>
  </tr>
</table>
<a class="anchor" name="z109_1" doxytag="LSMLIB::LevelSetMethodToolbox::computeSignedUnitNormalVectorFromPhi" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::computeSignedUnitNormalVectorFromPhi </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>patch_hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="namespaceLSMLIB.html#a6">SPATIAL_DERIVATIVE_TYPE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_derivative_type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_derivative_order</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>normal_vector_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z101_0">UNIT_NORMAL_TYPE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>unit_normal_type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_component</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z109_1">computeSignedUnitNormalVectorFromPhi()</a> computes the signed unit normal vector on AND off of the zero level set using the formula<p>
N = sgn(phi)*grad(phi)/|grad(phi)|<p>
given only data for phi.<p>
Arguments:<ul>
<li>patch_hierarchy (in): PatchHierarchy on which to compute stable normal velocity dt</li><li>spatial_derivative_type (in): type of spatial derivative calculation</li><li>spatial_derivative_order (in): order of spatial derivative</li><li>normal_vector_handle (out): PatchData handle for normal vector</li><li>phi_handle (in): PatchData handle for phi</li><li>unit_normal_type (in): specifies the method to use when computing the spatial derivatives used to compute the unit normal vector</li><li>phi_component (in): component of phi to use in computing normal vector (default = 0)</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>It is the user's responsibility to ensure that the PatchData for phi is defined with a sufficent number of ghost cells to support calculation of the selected ENO/WENO derivative in the interior of the PatchData for the unit normal vector.</li></ul>
<p>
<ul>
<li>The following formula is used for the smoothed sgn function:</li></ul>
<p>
sgn(phi) = phi/sqrt( phi^2 + |grad(phi)|^2 * dx^2 )     </td>
  </tr>
</table>
<a class="anchor" name="z111_0" doxytag="LSMLIB::LevelSetMethodToolbox::computeStableAdvectionDt" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> LSMLIB_REAL <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::computeStableAdvectionDt </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>patch_hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>velocity_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>control_volume_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const LSMLIB_REAL&nbsp;</td>
          <td class="mdname" nowrap> <em>cfl_number</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z111_0">computeStableAdvectionDt()</a> computes the maximum stable time step size for the advective term in a time evolution equation.<p>
Arguments:<ul>
<li>patch_hierarchy (in): PatchHierarchy on which to compute stable advection dt</li><li>velocity_handle (in): PatchData handle for velocity field data</li><li>control_volume_handle (in): PatchData handle for control volume</li><li>cfl_number (in): CFL number</li></ul>
<p>
Return value: none     </td>
  </tr>
</table>
<a class="anchor" name="z111_1" doxytag="LSMLIB::LevelSetMethodToolbox::computeStableNormalVelocityDt" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> LSMLIB_REAL <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::computeStableNormalVelocityDt </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>patch_hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>normal_velocity_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>grad_phi_plus_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>grad_phi_minus_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>control_volume_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const LSMLIB_REAL&nbsp;</td>
          <td class="mdname" nowrap> <em>cfl_number</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z111_1">computeStableNormalVelocityDt()</a> computes the maximum stable time step size for motion under a velocity in the normal direction.<p>
Arguments:<ul>
<li>patch_hierarchy (in): PatchHierarchy on which to compute stable normal velocity dt</li><li>normal_velocity_handle (in): PatchData handle for normal velocity field data</li><li>grad_phi_plus_handle (in): PatchData handle for grad(phi) computed using forward differencing</li><li>grad_phi_minus_handle (in): PatchData handle for grad(phi) computed using forward differencing</li><li>control_volume_handle (in): PatchData handle for control volume</li><li>cfl_number (in): CFL number</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>KTC - fill me in </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z109_7" doxytag="LSMLIB::LevelSetMethodToolbox::computeSurfaceIntegral" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> LSMLIB_REAL <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::computeSurfaceIntegral </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>patch_hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>F_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>grad_phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>control_volume_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>F_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>delta_width</em> = 3</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z109_7">computeSurfaceIntegral()</a> computes the surface integral over the specified function over the zero level set.<p>
Arguments:<ul>
<li>patch_hierarchy (in): PatchHierarchy on which to compute the volume integral</li><li>F_handle (in): PatchData handle for function to be integrated</li><li>phi_handle (in): PatchData handle for phi</li><li>grad_phi_handle (in): PatchData handle for grad(phi)</li><li>control_volume_handle (in): PatchData handle for control volume</li><li>F_component (in): component of F to use as integrand (default = 0)</li><li>phi_component (in): component of phi to use as level set function (default = 0)</li><li>delta_width (in): width of delta-function as a multiple of the grid spacing (default = 3)</li></ul>
<p>
Return value: integral of F over the zero level set<p>
NOTES:<ul>
<li>The accuracy of this calculation breaks down when zero level sets are very close together because there are not enough grid cells to compute the spatial derivatives required. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z109_2" doxytag="LSMLIB::LevelSetMethodToolbox::computeUnitNormalVectorFromGradPhi" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::computeUnitNormalVectorFromGradPhi </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>patch_hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>normal_vector_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>grad_phi_handle</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z109_2">computeUnitNormalVectorFromGradPhi()</a> computes the unit normal vector on AND off of the zero level set using the formula<p>
N = grad(phi)/|grad(phi)|<p>
given data for phi AND grad(phi). That is, the user is free to choose his/her own scheme for computing grad(phi).<p>
Arguments:<ul>
<li>patch_hierarchy (in): PatchHierarchy on which to compute stable normal velocity dt</li><li>normal_vector_handle (out): PatchData handle for normal vector</li><li>grad_phi_handle (in): PatchData handle for grad(phi)</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>There are no restrictions on the number of ghostcells for any of the data. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z109_0" doxytag="LSMLIB::LevelSetMethodToolbox::computeUnitNormalVectorFromPhi" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::computeUnitNormalVectorFromPhi </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>patch_hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="namespaceLSMLIB.html#a6">SPATIAL_DERIVATIVE_TYPE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_derivative_type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_derivative_order</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>normal_vector_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z101_0">UNIT_NORMAL_TYPE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>unit_normal_type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_component</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z109_0">computeUnitNormalVectorFromPhi()</a> computes the unit normal vector on AND off of the zero level set using the formula<p>
N = grad(phi)/|grad(phi)|<p>
given only data for phi.<p>
Arguments:<ul>
<li>patch_hierarchy (in): PatchHierarchy on which to compute stable normal velocity dt</li><li>spatial_derivative_type (in): type of spatial derivative calculation</li><li>spatial_derivative_order (in): order of spatial derivative</li><li>normal_vector_handle (out): PatchData handle for normal vector</li><li>phi_handle (in): PatchData handle for phi</li><li>unit_normal_type (in): specifies the method to use when computing the spatial derivatives used to compute the unit normal vector</li><li>phi_component (in): component of phi to use in computing normal vector (default = 0)</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>It is the user's responsibility to ensure that the PatchData for phi is defined with a sufficent number of ghost cells to support calculation of the selected ENO/WENO derivative in the interior of the PatchData for the unit normal vector. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z103_0" doxytag="LSMLIB::LevelSetMethodToolbox::computeUpwindSpatialDerivatives" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::computeUpwindSpatialDerivatives </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="namespaceLSMLIB.html#a6">SPATIAL_DERIVATIVE_TYPE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_derivative_type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_derivative_order</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>grad_phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>upwind_function_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_component</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z103_0">computeUpwindSpatialDerivatives()</a> computes upwind spatial derivatives using the specified ENO/WENO scheme specified.<p>
Arguments:<ul>
<li>hierarchy (in): Pointer to PatchHierarchy containing data</li><li>spatial_derivative_type (in): type of spatial derivative calculation</li><li>spatial_derivative_order (in): order of spatial derivative</li><li>grad_phi_handle (out): PatchData handle for grad(phi)</li><li>phi_handle (in): PatchData handle for phi</li><li>upwind_function_handle(in): PatchData handle for upwinding function</li><li>phi_component (in): component of phi for which to compute spatial derivatives (default = 0)</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>Support is only provided for the computation of the following spatial derivatives: ENO1 (i.e. 1st-order upwinding), ENO2, ENO3, and WENO5.</li></ul>
<p>
<ul>
<li>It is the user's responsibility to ensure that the PatchData for phi is defined with a sufficent number of ghost cells to support calculation of the selected ENO/WENO derivative in the interior of the PatchData for grad(phi).</li></ul>
<p>
<ul>
<li>For more details about the numerical discretizations used by <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z103_0">computeUpwindSpatialDerivatives()</a>, see "Level Set Methods and Dynamic Implicit Surfaces" by Osher &amp; Fedkiw. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z109_6" doxytag="LSMLIB::LevelSetMethodToolbox::computeVolumeIntegral" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> LSMLIB_REAL <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::computeVolumeIntegral </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>patch_hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>F_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>control_volume_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>region_integrator</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>F_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>heaviside_width</em> = 3</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z109_6">computeVolumeIntegral()</a> computes the volume integral of the specified function over one of two regions: region with phi &lt; 0 or region with phi &gt; 0.<p>
Arguments:<ul>
<li>patch_hierarchy (in): PatchHierarchy on which to compute the volume integral</li><li>F_handle (in): PatchData handle for function to be integrated</li><li>phi_handle (in): PatchData handle for phi</li><li>control_volume_handle (in): PatchData handle for control volume</li><li>region_indicator(in): integer indicating which region to integrate over<ul>
<li>(&gt;0): integration region = {x | phi(x) &gt; 0}</li><li>(&lt;=0): integration region = {x | phi(x) &lt;= 0}</li></ul>
</li><li>F_component (in): component of F to use as integrand (default = 0)</li><li>phi_component (in): component of phi to use as level set function (default = 0)</li><li>heaviside_width (in): width of Heaviside function as a multiple of the grid spacing (default = 3)</li></ul>
<p>
Return value: integral of F over the specified domain     </td>
  </tr>
</table>
<a class="anchor" name="z109_4" doxytag="LSMLIB::LevelSetMethodToolbox::computeVolumeOfRegionDefinedByZeroLevelSet" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> LSMLIB_REAL <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::computeVolumeOfRegionDefinedByZeroLevelSet </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>patch_hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>control_volume_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>region_indicator</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>heaviside_width</em> = 3</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z109_4">computeVolumeOfRegionDefinedByZeroLevelSet()</a> computes the volume of one of two regions: region with phi &lt; 0 or region with phi &gt; 0.<p>
Arguments:<ul>
<li>patch_hierarchy (in): PatchHierarchy on which to compute the volume integral</li><li>phi_handle (in): PatchData handle for phi</li><li>control_volume_handle (in): PatchData handle for control volume</li><li>region_indicator(in): integer indicating which region to integrate over<ul>
<li>(&gt;0): integration region = {x | phi(x) &gt; 0}</li><li>(&lt;=0): integration region = {x | phi(x) &lt;= 0}</li></ul>
</li><li>phi_component (in): component of phi to use as level set function (default = 0)</li><li>heaviside_width (in): width of Heaviside function as a multiple of the grid spacing (default = 3)</li></ul>
<p>
Return value: volume of the specified domain that is enclosed by the zero level set     </td>
  </tr>
</table>
<a class="anchor" name="z109_5" doxytag="LSMLIB::LevelSetMethodToolbox::computeVolumeOfZeroLevelSet" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> LSMLIB_REAL <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::computeVolumeOfZeroLevelSet </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>patch_hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>grad_phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>control_volume_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>delta_width</em> = 3</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z109_5">computeVolumeOfZeroLevelSet()</a> computes the volume of the codimension-one region defined by the zero level set (i.e. surface area for 3D problems, perimeter for 2D problems, number of points for 1D problems).<p>
Arguments:<ul>
<li>patch_hierarchy (in): PatchHierarchy on which to compute the volume integral</li><li>phi_handle (in): PatchData handle for phi</li><li>grad_phi_handle (in): PatchData handle for grad(phi)</li><li>control_volume_handle (in): PatchData handle for control volume</li><li>phi_component (in): component of phi to use as level set function (default = 0)</li><li>delta_width (in): width of delta-function as a multiple of the grid spacing (default = 3)</li></ul>
<p>
Return value: volume of zero level set<p>
NOTES:<ul>
<li>The accuracy of this calculation breaks down when zero level sets are very close together because there are not enough grid cells to compute the spatial derivatives required. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z111_4" doxytag="LSMLIB::LevelSetMethodToolbox::copySAMRAIData" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::copySAMRAIData </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>patch_hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>dst_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>src_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>dst_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>src_component</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z111_4">copySAMRAIData()</a> copies data from the PatchData associated with the source handle to the PatchData associated with the destination handle for the specified components. It only copies data in the interior of the Patch.<p>
Arguments:<ul>
<li>patch_hierarchy (in): PatchHierarchy on which to copy data</li><li>dst_handle (out): PatchData handle for scratch space</li><li>src_handle (in): PatchData handle for data to be copied to scratch space</li><li>dst_component (in): component of scratch space data to copy to (default = 0)</li><li>src_component (in): component of data to be copied to scratch space (default = 0)</li></ul>
<p>
Return value: none     </td>
  </tr>
</table>
<a class="anchor" name="z113_0" doxytag="LSMLIB::LevelSetMethodToolbox::initializeComputeSpatialDerivativesParameters" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::initializeComputeSpatialDerivativesParameters </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static, protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z113_0">initializeComputeSpatialDerivativesParameters()</a> sets up the parameters required for computing spatial derivatives.<p>
Arguments: none<p>
Return value: none     </td>
  </tr>
</table>
<a class="anchor" name="z113_1" doxytag="LSMLIB::LevelSetMethodToolbox::initializeComputeUnitNormalParameters" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::initializeComputeUnitNormalParameters </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static, protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z113_1">initializeComputeUnitNormalParameters()</a> sets up the parameters required for computing the unit normal vector.<p>
Arguments: none<p>
Return value: none     </td>
  </tr>
</table>
<a class="anchor" name="z111_2" doxytag="LSMLIB::LevelSetMethodToolbox::maxNormOfDifference" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> LSMLIB_REAL <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::maxNormOfDifference </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>field1_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>field2_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>control_volume_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>field1_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>field2_component</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z111_2">maxNormOfDifference()</a> computes the max norm of the difference two scalar fields.<p>
Arguments:<ul>
<li>hierarchy (in): Pointer to PatchHierarchy containing data</li><li>field1_handle (in): PatchData handle for field1</li><li>field2_handle (in): PatchData handle for field2</li><li>control_volume_handle (in): PatchData handle for control volume</li><li>field1_component (in): component of field1 to use (default = 0)</li><li>field2_component (in): component of field2 to use (default = 0)</li></ul>
<p>
Return value: max norm of (field1 - field2)     </td>
  </tr>
</table>
<a class="anchor" name="z105_0" doxytag="LSMLIB::LevelSetMethodToolbox::TVDRK1Step" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::TVDRK1Step </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_next_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_cur_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>rhs_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const LSMLIB_REAL&nbsp;</td>
          <td class="mdname" nowrap> <em>dt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_next_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_cur_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>rhs_component</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z105_0">TVDRK1Step()</a> advances the solution through a single step of the first-order Runge-Kutta method (i.e. forward euler).<p>
Arguments:<ul>
<li>hierarchy (in): Pointer to PatchHierarchy containing data</li><li>u_next_handle (out): PatchData handle for u(t+dt)</li><li>u_cur_handle (in): PatchData handle for u(t)</li><li>rhs_handle (in): PatchData handle for rhs(t)</li><li>dt (in): time increment to advance u</li><li>u_next_component (in): component of u_next to use in step (default = 0)</li><li>u_cur_component (in): component of u_cur to use in step (default = 0)</li><li>rhs_component (in): component of rhs to use in step (default = 0)</li></ul>
<p>
Return value: none     </td>
  </tr>
</table>
<a class="anchor" name="z105_1" doxytag="LSMLIB::LevelSetMethodToolbox::TVDRK2Stage1" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::TVDRK2Stage1 </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_stage1_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_cur_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>rhs_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const LSMLIB_REAL&nbsp;</td>
          <td class="mdname" nowrap> <em>dt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_stage1_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_cur_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>rhs_component</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z105_1">TVDRK2Stage1()</a> advances the solution through the first stage of the second-order TVD Runge-Kutta method<p>
Arguments:<ul>
<li>hierarchy (in): Pointer to PatchHierarchy containing data</li><li>u_stage1_handle (out): PatchData handle for u_approx(t+dt)</li><li>u_cur_handle (in): PatchData handle for u(t)</li><li>rhs_handle (in): PatchData handle for rhs(t)</li><li>dt (in): time increment to advance u</li><li>u_stage1_component (in): component of u_stage1 to use in step (default = 0)</li><li>u_cur_component (in): component of u_cur to use in step (default = 0)</li><li>rhs_component (in): component of rhs to use in step (default = 0)</li></ul>
<p>
Return value: none     </td>
  </tr>
</table>
<a class="anchor" name="z105_2" doxytag="LSMLIB::LevelSetMethodToolbox::TVDRK2Stage2" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::TVDRK2Stage2 </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_next_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_stage1_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_cur_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>rhs_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const LSMLIB_REAL&nbsp;</td>
          <td class="mdname" nowrap> <em>dt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_next_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_stage1_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_cur_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>rhs_component</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z105_2">TVDRK2Stage2()</a> completes advancing the solution through a a single step of the second-order TVD Runge-Kutta method.<p>
Arguments:<ul>
<li>hierarchy (in): Pointer to PatchHierarchy containing data</li><li>u_next_handle (out): PatchData handle for u(t+dt)</li><li>u_stage1_handle (in): PatchData handle for u_approx(t+dt)</li><li>u_cur_handle (in): PatchData handle for u(t)</li><li>rhs_handle (in): PatchData handle for rhs(t)</li><li>dt (in): time increment to advance u</li><li>u_next_component (in): component of u_next to use in step (default = 0)</li><li>u_stage1_component (in): component of u_stage1 to use in step (default = 0)</li><li>u_cur_component (in): component of u_cur to use in step (default = 0)</li><li>rhs_component (in): component of rhs to use in step (default = 0)</li></ul>
<p>
Return value: none     </td>
  </tr>
</table>
<a class="anchor" name="z105_3" doxytag="LSMLIB::LevelSetMethodToolbox::TVDRK3Stage1" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::TVDRK3Stage1 </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_stage1_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_cur_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>rhs_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const LSMLIB_REAL&nbsp;</td>
          <td class="mdname" nowrap> <em>dt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_stage1_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_cur_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>rhs_component</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z105_3">TVDRK3Stage1()</a> advances the solution through the first stage of the third-order TVD Runge-Kutta method<p>
Arguments:<ul>
<li>hierarchy (in): Pointer to PatchHierarchy containing data</li><li>u_stage1_handle (out): PatchData handle for u_approx(t+dt)</li><li>u_cur_handle (in): PatchData handle for u(t)</li><li>rhs_handle (in): PatchData handle for rhs(t)</li><li>dt (in): time increment to advance u</li><li>u_stage1_component (in): component of u_stage1 to use in step (default = 0)</li><li>u_cur_component (in): component of u_cur to use in step (default = 0)</li><li>rhs_component (in): component of rhs to use in step (default = 0)</li></ul>
<p>
Return value: none     </td>
  </tr>
</table>
<a class="anchor" name="z105_4" doxytag="LSMLIB::LevelSetMethodToolbox::TVDRK3Stage2" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::TVDRK3Stage2 </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_stage2_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_stage1_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_cur_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>rhs_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const LSMLIB_REAL&nbsp;</td>
          <td class="mdname" nowrap> <em>dt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_stage2_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_stage1_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_cur_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>rhs_component</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z105_4">TVDRK3Stage2()</a> advances the solution through the second stage of the third-order TVD Runge-Kutta method<p>
Arguments:<ul>
<li>hierarchy (in): Pointer to PatchHierarchy containing data</li><li>u_stage2_handle (out): PatchData handle for u_approx(t+dt/2)</li><li>u_stage1_handle (in): PatchData handle for u_approx(t+dt)</li><li>u_cur_handle (in): PatchData handle for u(t)</li><li>rhs_handle (in): PatchData handle for rhs(t)</li><li>dt (in): time increment to advance u</li><li>u_stage2_component (in): component of u_stage2 to use in step (default = 0)</li><li>u_stage1_component (in): component of u_stage1 to use in step (default = 0)</li><li>u_cur_component (in): component of u_cur to use in step (default = 0)</li><li>rhs_component (in): component of rhs to use in step (default = 0)</li></ul>
<p>
Return value: none     </td>
  </tr>
</table>
<a class="anchor" name="z105_5" doxytag="LSMLIB::LevelSetMethodToolbox::TVDRK3Stage3" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::TVDRK3Stage3 </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_next_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_stage2_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_cur_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>rhs_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const LSMLIB_REAL&nbsp;</td>
          <td class="mdname" nowrap> <em>dt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_next_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_stage2_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>u_cur_component</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>rhs_component</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#z105_5">TVDRK3Stage3()</a> completes advancing the solution through a a single step of the third-order TVD Runge-Kutta method.<p>
Arguments:<ul>
<li>hierarchy (in): Pointer to PatchHierarchy containing data</li><li>u_next_handle (out): PatchData handle for u(t+dt)</li><li>u_stage2_handle (in): PatchData handle for u_approx(t+dt/2)</li><li>u_cur_handle (in): PatchData handle for u(t)</li><li>rhs_handle (in): PatchData handle for rhs(t)</li><li>dt (in): time increment to advance u</li><li>u_next_component (in): component of u_next to use in step (default = 0)</li><li>u_stage2_component (in): component of u_stage2 to use in step (default = 0)</li><li>u_cur_component (in): component of u_cur to use in step (default = 0)</li><li>rhs_component (in): component of rhs to use in step (default = 0)</li></ul>
<p>
Return value: none     </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="t6" doxytag="LSMLIB::LevelSetMethodToolbox::s_compute_normal_grad_phi_handle" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#t6">s_compute_normal_grad_phi_handle</a><code> [static, protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="t8" doxytag="LSMLIB::LevelSetMethodToolbox::s_compute_normal_grad_phi_minus_handle" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#t8">s_compute_normal_grad_phi_minus_handle</a><code> [static, protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="t7" doxytag="LSMLIB::LevelSetMethodToolbox::s_compute_normal_grad_phi_plus_handle" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#t7">s_compute_normal_grad_phi_plus_handle</a><code> [static, protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="t0" doxytag="LSMLIB::LevelSetMethodToolbox::s_D1_one_ghostcell_handle" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#t0">s_D1_one_ghostcell_handle</a><code> [static, protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="t3" doxytag="LSMLIB::LevelSetMethodToolbox::s_D1_three_ghostcells_handle" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#t3">s_D1_three_ghostcells_handle</a><code> [static, protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="t1" doxytag="LSMLIB::LevelSetMethodToolbox::s_D1_two_ghostcells_handle" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#t1">s_D1_two_ghostcells_handle</a><code> [static, protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="t4" doxytag="LSMLIB::LevelSetMethodToolbox::s_D2_three_ghostcells_handle" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#t4">s_D2_three_ghostcells_handle</a><code> [static, protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="t2" doxytag="LSMLIB::LevelSetMethodToolbox::s_D2_two_ghostcells_handle" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#t2">s_D2_two_ghostcells_handle</a><code> [static, protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="t5" doxytag="LSMLIB::LevelSetMethodToolbox::s_D3_three_ghostcells_handle" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int <a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html">LSMLIB::LevelSetMethodToolbox</a>&lt; DIM &gt;::<a class="el" href="classLSMLIB_1_1LevelSetMethodToolbox.html#t5">s_D3_three_ghostcells_handle</a><code> [static, protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="LevelSetMethodToolbox_8h-source.html">LevelSetMethodToolbox.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Sun May 3 19:14:23 2009 for LSMLIB by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
