<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LSMLIB:  TemplateLSMLIB::LevelSetMethodVelocityFieldStrategy&lt; DIM &gt; class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>LSMLIB::LevelSetMethodVelocityFieldStrategy&lt; DIM &gt; Class Template Reference</h1>The <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LevelSetMethodVelocityFieldStrategy</a> class defines the interface for supplying the external velocity field and/or normal velocity field for a level set method calculation.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="LevelSetMethodVelocityFieldStrategy_8h-source.html">LevelSetMethodVelocityFieldStrategy.h</a>&gt;</code>
<p>
<a href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods related to calculation of velocity field</div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html#z115_0">providesExternalVelocityField</a> () const =0</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html#z115_1">providesNormalVelocityField</a> () const =0</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html#z115_2">getExternalVelocityFieldPatchDataHandle</a> (const  int component) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html#z115_3">getNormalVelocityFieldPatchDataHandle</a> (const  <a class="el" href="namespaceLSMLIB.html#a5">LEVEL_SET_FCN_TYPE</a> level_set_fcn, const  int component) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html#z115_4">computeVelocityField</a> (const  LSMLIB_REAL time, const  int phi_handle, const  int psi_handle, const  int component)=0</td></tr>

<tr><td colspan="2"><div class="groupHeader">Methods related to time integration</div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html#z117_0">setCurrentTime</a> (const  LSMLIB_REAL time)=0</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual LSMLIB_REAL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html#z117_1">computeStableDt</a> ()=0</td></tr>

<tr><td colspan="2"><div class="groupHeader">Methods for initializing data</div></td></tr>
<tr><td colspan="2"><div class="groupText">NOTES:<ul>
<li>initializeLevelData() essentially emulate the method of the same name declared in the SAMRAI::mesh::StandardTagAndInitStrategy class but with access to level set function data </li></ul>
<br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html#z119_0">initializeLevelData</a> (const  Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; hierarchy, const  int level_number, const  LSMLIB_REAL init_data_time, const  int phi_handle, const  int psi_handle, const  bool can_be_refined, const  bool initial_time, const  Pointer&lt; PatchLevel&lt; DIM &gt; &gt; old_level=Pointer&lt; PatchLevel&lt; DIM &gt; &gt;((0)), const  bool allocate_data=true)=0</td></tr>

<tr><td colspan="2"><div class="groupHeader">Methods for managing grid configuration</div></td></tr>
<tr><td colspan="2"><div class="groupText">NOTES:<ul>
<li>resetHierarchyConfiguration() exactly mimics the method of the same name declared in the SAMRAI::mesh::StandardTagAndInitStrategy class</li></ul>
<p>
<ul>
<li>tagCellsForRefinement() essentially emulates applyGradientDetector() in the the SAMRAI::mesh::StandardTagAndInitStrategy class </li></ul>
<br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html#z121_0">resetHierarchyConfiguration</a> (Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; hierarchy, int coarsest_level, int finest_level)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html#z121_1">tagCellsForRefinement</a> (const  Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt; hierarchy, const  int level_number, const  int tag_handle)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Destructors</div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html#z123_0">~LevelSetMethodVelocityFieldStrategy</a> ()</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int DIM&gt;<br>
 class LSMLIB::LevelSetMethodVelocityFieldStrategy&lt; DIM &gt;</h3>

The <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LevelSetMethodVelocityFieldStrategy</a> class defines the interface for supplying the external velocity field and/or normal velocity field for a level set method calculation. 
<p>
In particular, it defines interfaces for computing the velocity field used in a level set method calculation, computing a stable time step size based on the velocity field computation, and accessing the PatchData handles for the velocity field data. The interface also defines methods for initializing the data required for the velocity field calculation, resetting the PatchHierarchy configuation (after a regridding operation), and tagging cells for refinement. These methods emulate similarly named methods in the SAMRAI::mesh::StandardTagAndInitStrategy&lt;DIM&gt; class (in the <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> library).<p>
<h3>NOTES: </h3>
<p>
<ul>
<li>In order to use the <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> class, a user MUST implement a concrete subclass of this ``strategy'' class.</li></ul>
<p>
<ul>
<li>It is NOT required that the user-defined subclass provides support for both external (vector) and normal (scalar) velocity fields. However, at least one of these velocity fields MUST be provided by the user-defined subclass. Depending on the application either one (or both) velocity fields may be required in the user-defined subclass.</li></ul>
<p>
<ul>
<li>If restart capabilities are desired for the application, the concrete subclass of <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LevelSetMethodVelocityFieldStrategy</a> MUST register all PatchData for required restart using the SAMRAI::VariableDatabase::registerPatchDataForRestart() method.</li></ul>
<p>
<ul>
<li>Default (empty) implementations of <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html#z121_0">resetHierarchyConfiguration()</a> and <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html#z121_1">tagCellsForRefinement()</a> are provided for convenience if AMR is not required by the user's application. </li></ul>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="z123_0" doxytag="LSMLIB::LevelSetMethodVelocityFieldStrategy::~LevelSetMethodVelocityFieldStrategy" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LSMLIB::LevelSetMethodVelocityFieldStrategy</a>&lt; DIM &gt;::~<a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LevelSetMethodVelocityFieldStrategy</a> </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructor does nothing but must be declared virtual so that concrete subclasses are properly destroyed.     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="z117_1" doxytag="LSMLIB::LevelSetMethodVelocityFieldStrategy::computeStableDt" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual LSMLIB_REAL <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LSMLIB::LevelSetMethodVelocityFieldStrategy</a>&lt; DIM &gt;::computeStableDt </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html#z117_1">computeStableDt()</a> returns the maximum acceptable (stable) time step size allowed in order to maintain numerical stability of the calculation used to compute the velocity field. This often comes from the physics of the problem (e.g. inherent time-variation in an external velocity field).<p>
Arguments: none<p>
Return value: maximum acceptable time step<p>
NOTES:<ul>
<li>This is a pure abstract method that the user MUST override in order to use the <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> class. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z115_4" doxytag="LSMLIB::LevelSetMethodVelocityFieldStrategy::computeVelocityField" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LSMLIB::LevelSetMethodVelocityFieldStrategy</a>&lt; DIM &gt;::computeVelocityField </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const LSMLIB_REAL&nbsp;</td>
          <td class="mdname" nowrap> <em>time</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>psi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>component</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html#z115_4">computeVelocityField()</a> computes all necessary level set method velocity fields on the entire hierarchy.<p>
Arguments:<ul>
<li>time (in): time that velocity field is to be computed</li><li>phi_handle (in): PatchData handle for phi</li><li>psi_handle (in): PatchData handle for psi</li><li>component (in): component of level set functions for which to compute velocity field</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>Whether the external (vector) velocity field or just a normal (scalar) velocity is computed depends on the specific application.</li></ul>
<p>
<ul>
<li>phi_handle, psi_handle, phi_component, and psi_component are provided for applications that use information about the level set functions to compute the velocity field. They are NOT guaranteed to be the same between calls to <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html#z115_4">computeVelocityField()</a>.</li></ul>
<p>
<ul>
<li>The number of ghostcells for the PatchData associated with phi_handle and psi_handle is equal to the number required to compute spatial derivatives using the type and order specified in the input database for the <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a>. Specifically, the number of ghostcells are one, two, and three for first-, second-, and third-order ENO spatial derivatives, respectively. The number of ghostcells is equal to three for fifth-order WENO spatial derivatives.</li></ul>
<p>
<ul>
<li>For codimension-one problems, psi_handle is NOT guaranteed to be set to a valid PatchData handle, so it should be ignored in the user-defined version of this method.</li></ul>
<p>
<ul>
<li>This is a pure abstract method that the user MUST override in order to use the <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> class. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z115_2" doxytag="LSMLIB::LevelSetMethodVelocityFieldStrategy::getExternalVelocityFieldPatchDataHandle" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual int <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LSMLIB::LevelSetMethodVelocityFieldStrategy</a>&lt; DIM &gt;::getExternalVelocityFieldPatchDataHandle </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>component</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Accessor method for the external (vector) velocity field PatchData handle.<p>
Arguments:<ul>
<li>component (in): component of vector level set function that the velocity field handle is being requested for</li></ul>
<p>
Return value: PatchData handle for the external velocity field data<p>
NOTES:<ul>
<li>This is a pure abstract method that the user MUST override in order to use the <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> class. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z115_3" doxytag="LSMLIB::LevelSetMethodVelocityFieldStrategy::getNormalVelocityFieldPatchDataHandle" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual int <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LSMLIB::LevelSetMethodVelocityFieldStrategy</a>&lt; DIM &gt;::getNormalVelocityFieldPatchDataHandle </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="namespaceLSMLIB.html#a5">LEVEL_SET_FCN_TYPE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>level_set_fcn</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>component</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Accessor method for the normal (scalar) velocity field PatchData handle.<p>
Arguments:<ul>
<li>level_set_fcn (in): level set function for which to get normal velocity field PatchData handle</li><li>component (in): component of vector level set function that the normal velocity field handle is being requested for</li></ul>
<p>
Return value: PatchData handle for the normal velocity field data<p>
NOTES:<ul>
<li>The level set function is required as an argument because the the normal velocity depends on the orientation of the zero level set (which is a function of the level set function).</li></ul>
<p>
<ul>
<li>This is a pure abstract method that the user MUST override in order to use the <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> class. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z119_0" doxytag="LSMLIB::LevelSetMethodVelocityFieldStrategy::initializeLevelData" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LSMLIB::LevelSetMethodVelocityFieldStrategy</a>&lt; DIM &gt;::initializeLevelData </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const LSMLIB_REAL&nbsp;</td>
          <td class="mdname" nowrap> <em>init_data_time</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>phi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>psi_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bool&nbsp;</td>
          <td class="mdname" nowrap> <em>can_be_refined</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bool&nbsp;</td>
          <td class="mdname" nowrap> <em>initial_time</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const Pointer&lt; PatchLevel&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>old_level</em> = Pointer&lt; PatchLevel&lt; DIM &gt; &gt;((0)), </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bool&nbsp;</td>
          <td class="mdname" nowrap> <em>allocate_data</em> = true</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html#z119_0">initializeLevelData()</a> allocates and initializes any PatchData related to the computation of the velocity field for a PatchLevel that has been newly added to the PatchHierarchy.<p>
Arguments:<ul>
<li>hierarchy (in): PatchHierarchy on which to tag cells for refinement</li><li>level_number (in): PatchLevel number on which to tag cells for refinement</li><li>phi_handle (in): PatchData handle for phi</li><li>psi_handle (in): PatchData handle for psi</li><li>can_be_refined (in): true if this is NOT the finest level in the PatchHierarchy; false it if is</li><li>init_data_time (in): true if the PatchLevel is being introduced for the first time; false otherwise</li><li>old_level (in): old PatchLevel from which data for new PatchLevel should be taken</li><li>allocate_data (in): true if PatchData needs to be allocated before it is initialized; false otherwise</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>The number of ghostcells for phi and psi data depends on the type and order of spatial derivative selected for the <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a>:</li></ul>
<p>
<ul>
<li>ENO-1: 1</li><li>ENO-2: 2</li><li>ENO-3: 3</li><li>WENO-5: 3</li></ul>
<p>
<ul>
<li>For codimension-one problems, psi_handle is NOT guaranteed to be set to a valid PatchData handle, so it should be ignored in the user-defined version of this method.</li></ul>
<p>
<ul>
<li>This is a pure abstract method that the user MUST override in order to use the <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> class. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z115_0" doxytag="LSMLIB::LevelSetMethodVelocityFieldStrategy::providesExternalVelocityField" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual bool <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LSMLIB::LevelSetMethodVelocityFieldStrategy</a>&lt; DIM &gt;::providesExternalVelocityField </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html#z115_0">providesExternalVelocityField()</a> indicates whether the concrete subclass of <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LevelSetMethodVelocityFieldStrategy</a> provides an external (vector) velocity field for the level set method calculation.<p>
Arguments: none<p>
Return value: true if the object provides calculation of an external (vector) velocity field for a level set method calculation; false otherwise<p>
NOTES:<ul>
<li>This is a pure abstract method that the user MUST override in order to use the <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> class. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z115_1" doxytag="LSMLIB::LevelSetMethodVelocityFieldStrategy::providesNormalVelocityField" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual bool <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LSMLIB::LevelSetMethodVelocityFieldStrategy</a>&lt; DIM &gt;::providesNormalVelocityField </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html#z115_1">providesNormalVelocityField()</a> indicates whether the concrete subclass of <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LevelSetMethodVelocityFieldStrategy</a> provides an normal (scalar) velocity field for the level set method calculation.<p>
Arguments: none<p>
Return value: true if the object provides calculation of an normal (scalar) velocity field for a level set method calculation; false otherwise<p>
NOTES:<ul>
<li>This is a pure abstract method that the user MUST override in order to use the <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> class. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z121_0" doxytag="LSMLIB::LevelSetMethodVelocityFieldStrategy::resetHierarchyConfiguration" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LSMLIB::LevelSetMethodVelocityFieldStrategy</a>&lt; DIM &gt;::resetHierarchyConfiguration </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>coarsest_level</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>finest_level</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html#z121_0">resetHierarchyConfiguration()</a> resets any internal hierarchy-dependent information.<p>
Arguments:<ul>
<li>new_hierarchy (in): PatchHierarchy to configure</li><li>coarsest_level (in): level number of coarsest PatchLevel to reset</li><li>finest_level (in): level number of finest Patchlevel to reset</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>This method is virtual with an empty implementation here (rather than pure virtual) so that users do not need to provide an implementation when the method is not needed (e.g. when parallel computation and AMR is not required). </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z117_0" doxytag="LSMLIB::LevelSetMethodVelocityFieldStrategy::setCurrentTime" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LSMLIB::LevelSetMethodVelocityFieldStrategy</a>&lt; DIM &gt;::setCurrentTime </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const LSMLIB_REAL&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>time</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html#z117_0">setCurrentTime()</a> sets the current time for the VelocityFieldStrategy class so that the simulation time for the velocity field calculation can be synchronized with the simulation time for the level set method calculation.<p>
Arguments:<ul>
<li>time (in): new current time</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>This is a pure abstract method that the user MUST override in order to use the <a class="el" href="classLSMLIB_1_1LevelSetFunctionIntegrator.html">LevelSetFunctionIntegrator</a> class. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z121_1" doxytag="LSMLIB::LevelSetMethodVelocityFieldStrategy::tagCellsForRefinement" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void <a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html">LSMLIB::LevelSetMethodVelocityFieldStrategy</a>&lt; DIM &gt;::tagCellsForRefinement </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Pointer&lt; PatchHierarchy&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>tag_handle</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classLSMLIB_1_1LevelSetMethodVelocityFieldStrategy.html#z121_1">tagCellsForRefinement()</a> sets integer tags to "1" in cells where refinement of the given level should occur.<p>
Arguments:<ul>
<li>hierarchy (in): PatchHierarchy on which to tag cells for refinement</li><li>level_number (in): PatchLevel number on which to tag cells for refinement</li><li>tag_handle (in): PatchData handle for the cell-centered integer tag data</li></ul>
<p>
Return value: none<p>
NOTES:<ul>
<li>This method is virtual with an empty implementation here (rather than pure virtual) so that users do not need to provide an implementation when the method is not needed (e.g. when AMR is not required). </li></ul>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="LevelSetMethodVelocityFieldStrategy_8h-source.html">LevelSetMethodVelocityFieldStrategy.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Sun May 3 19:14:23 2009 for LSMLIB by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
