<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LSMLIB: lsm_fast_marching_method.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>lsm_fast_marching_method.h File Reference</h1><a class="el" href="lsm__fast__marching__method_8h.html">lsm_fast_marching_method.h</a> provides support for basic fast marching method calculations: computing distance functions, extensions of field variables (e.g. extension velocities, etc.) off of the zero contour of a level set function, and solving the Eikonal equation.  
<a href="#_details">More...</a>
<p>
<code>#include "LSMLIB_config.h"</code><br>
<code>#include "<a class="el" href="FMM__Core_8h-source.html">FMM_Core.h</a>"</code><br>

<p>
<a href="lsm__fast__marching__method_8h-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsm__fast__marching__method_8h.html#a0">computeExtensionFields2d</a> (LSMLIB_REAL *distance_function, LSMLIB_REAL **extension_fields, LSMLIB_REAL *phi, LSMLIB_REAL *mark, LSMLIB_REAL **source_fields, int num_extension_fields, int spatial_discretization_order, int *grid_dims, LSMLIB_REAL *dx)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsm__fast__marching__method_8h.html#a1">computeDistanceFunction2d</a> (LSMLIB_REAL *distance_function, LSMLIB_REAL *phi, LSMLIB_REAL *mark, int spatial_discretization_order, int *grid_dims, LSMLIB_REAL *dx)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsm__fast__marching__method_8h.html#a2">solveEikonalEquation2d</a> (LSMLIB_REAL *phi, LSMLIB_REAL *speed, LSMLIB_REAL *mask, int spatial_discretization_order, int *grid_dims, LSMLIB_REAL *dx)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsm__fast__marching__method_8h.html#a3">computeExtensionFields3d</a> (LSMLIB_REAL *distance_function, LSMLIB_REAL **extension_fields, LSMLIB_REAL *phi, LSMLIB_REAL *mask, LSMLIB_REAL **source_fields, int num_extension_fields, int spatial_discretization_order, int *grid_dims, LSMLIB_REAL *dx)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsm__fast__marching__method_8h.html#a4">computeDistanceFunction3d</a> (LSMLIB_REAL *distance_function, LSMLIB_REAL *phi, LSMLIB_REAL *mask, int spatial_discretization_order, int *grid_dims, LSMLIB_REAL *dx)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsm__fast__marching__method_8h.html#a5">solveEikonalEquation3d</a> (LSMLIB_REAL *phi, LSMLIB_REAL *speed, LSMLIB_REAL *mask, int spatial_discretization_order, int *grid_dims, LSMLIB_REAL *dx)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="lsm__fast__marching__method_8h.html">lsm_fast_marching_method.h</a> provides support for basic fast marching method calculations: computing distance functions, extensions of field variables (e.g. extension velocities, etc.) off of the zero contour of a level set function, and solving the Eikonal equation. 
<p>
The algorithm (and naming) closely follows the description in "Level Set Methods and Fast Marching Methods" by J.A. Sethian and "The Fast Construction of Extension Velocities in Level Set Methods" by D. Adalsteinsson and J.A. Sethian (J. Comp. Phys, vol 148, p 2-22, 1999).<p>
<h3>NOTES </h3>
<p>
<ul>
<li>The fast marching method library assumes that the field data are stored in Fortran order (i.e. column-major order).</li></ul>
<p>
<ul>
<li>Error Codes: 0 - successful computation, 1 - FMM_Data creation error, 2 - invalid spatial discretization order</li></ul>
<p>
<ul>
<li>While <a class="el" href="lsm__fast__marching__method_8h.html">lsm_fast_marching_method.h</a> only provides functions for 2D and 3D FMM calculations, <a class="el" href="namespaceLSMLIB.html">LSMLIB</a> is capable of supporting higher dimensional calculations (currently as high as 8, set by FMM_HEAP_MAX_NDIM in <a class="el" href="FMM__Heap_8h.html">FMM_Heap.h</a>). To use <a class="el" href="namespaceLSMLIB.html">LSMLIB</a> to do higher dimensional fast marching method calculations, just modify lsm_FMM_field_extension*d.c and/or lsm_FMM_eikonal*d.c so that the data array sizes and index calculations are appropriate for the dimensionality of the problem of interest.</li></ul>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a1" doxytag="lsm_fast_marching_method.h::computeDistanceFunction2d" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int computeDistanceFunction2d </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LSMLIB_REAL *&nbsp;</td>
          <td class="mdname" nowrap> <em>distance_function</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>LSMLIB_REAL *&nbsp;</td>
          <td class="mdname" nowrap> <em>phi</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>LSMLIB_REAL *&nbsp;</td>
          <td class="mdname" nowrap> <em>mark</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_discretization_order</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>grid_dims</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>LSMLIB_REAL *&nbsp;</td>
          <td class="mdname" nowrap> <em>dx</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
computeDistanceFunction2d uses the FMM algorithm to compute the a distance function from the original level set function, phi.<p>
Arguments:<ul>
<li>distance_function (out): updated distance function</li><li>phi (in): original level set function</li><li>mask (in): mask for domain of problem; grid points outside of the domain of the problem should be set to a negative value.</li><li>spatial_discretization_order (in): order of finite differences used to compute spatial derivatives</li><li>grid_dims (in): array of index space extents for all fields</li><li>dx (in): array of grid cell sizes in each coordinate direction</li></ul>
<p>
Return value: error code (see NOTES for translation)<p>
NOTES:<ul>
<li>The distance function computed when using a second-order spatial discretization are approximately second-order accurate in the L2 norm but are only first-order accurate in the L-infinity norm. The reason for this behavior is that the current implementation uses only a first-order accurate scheme for initializing the grid points around the zero-level set.</li></ul>
<p>
<ul>
<li>For grid points that are masked out, the distance function is set to 0.</li></ul>
<p>
<ul>
<li>It is assumed that the user has allocated the memory for the distance function and phi fields.</li></ul>
<p>
<ul>
<li>If mask is set to a NULL pointer, then all grid points are treated as being in the interior of the domain.</li></ul>
<p>
<ul>
<li>It is assumed that the phi and mask data arrays are both of the same size. That is, all data fields are assumed to have the same index space extents. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="lsm_fast_marching_method.h::computeDistanceFunction3d" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int computeDistanceFunction3d </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LSMLIB_REAL *&nbsp;</td>
          <td class="mdname" nowrap> <em>distance_function</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>LSMLIB_REAL *&nbsp;</td>
          <td class="mdname" nowrap> <em>phi</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>LSMLIB_REAL *&nbsp;</td>
          <td class="mdname" nowrap> <em>mask</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_discretization_order</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>grid_dims</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>LSMLIB_REAL *&nbsp;</td>
          <td class="mdname" nowrap> <em>dx</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
computeDistanceFunction3d uses the FMM algorithm to compute the a distance function from the original level set function, phi.<p>
Arguments:<ul>
<li>distance_function (out): updated distance function</li><li>phi (in): original level set function</li><li>mask (in): mask for domain of problem; grid points outside of the domain of the problem should be set to a negative value.</li><li>spatial_discretization_order (in): order of finite differences used to compute spatial derivatives</li><li>grid_dims (in): array of index space extents for all fields</li><li>dx (in): array of grid cell sizes in each coordinate direction</li></ul>
<p>
Return value: error code (see NOTES for translation)<p>
NOTES:<ul>
<li>The distance function computed when using a second-order spatial discretization are approximately second-order accurate in the L2 norm but are only first-order accurate in the L-infinity norm. The reason for this behavior is that the current implementation uses only a first-order accurate scheme for initializing the grid points around the zero-level set.</li></ul>
<p>
<ul>
<li>For grid points that are masked out, the distance function is set to 0.</li></ul>
<p>
<ul>
<li>It is assumed that the user has allocated the memory for the distance function and phi fields.</li></ul>
<p>
<ul>
<li>If mask is set to a NULL pointer, then all grid points are treated as being in the interior of the domain.</li></ul>
<p>
<ul>
<li>It is assumed that the phi and mask data arrays are both of the same size. That is, all data fields are assumed to have the same index space extents. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="lsm_fast_marching_method.h::computeExtensionFields2d" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int computeExtensionFields2d </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LSMLIB_REAL *&nbsp;</td>
          <td class="mdname" nowrap> <em>distance_function</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>LSMLIB_REAL **&nbsp;</td>
          <td class="mdname" nowrap> <em>extension_fields</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>LSMLIB_REAL *&nbsp;</td>
          <td class="mdname" nowrap> <em>phi</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>LSMLIB_REAL *&nbsp;</td>
          <td class="mdname" nowrap> <em>mark</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>LSMLIB_REAL **&nbsp;</td>
          <td class="mdname" nowrap> <em>source_fields</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>num_extension_fields</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_discretization_order</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>grid_dims</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>LSMLIB_REAL *&nbsp;</td>
          <td class="mdname" nowrap> <em>dx</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
computeExtensionFields2d uses the FMM algorithm to compute the distance function and extension fields from the original level set function, phi, and the specified source fields.<p>
Arguments:<ul>
<li>distance_function (out): updated distance function</li><li>extension_fields (out): extension fields</li><li>phi (in): original level set function</li><li>mask (in): mask for domain of problem; grid points outside of the domain of the problem should be set to a negative value.</li><li>source_fields(in): source fields used to compute extension fields</li><li>num_extension_fields (in): number of extension fields to compute</li><li>spatial_discretization_order (in): order of finite differences used to compute spatial derivatives</li><li>grid_dims (in): array of index space extents for all fields</li><li>dx (in): array of grid cell sizes in each coordinate direction</li></ul>
<p>
Return value: error code (see NOTES for translation)<p>
NOTES:<ul>
<li>When the second-order spatial discretization is requested, only the distance function is computed using the second-order scheme. The extension fields are computed using a first-order discretization of the gradient for the extension field and a second-order accurate discretization of the gradient for the distance function. We use a first-order discretization when computing extension fields because the second-order discretization is "unstable" and leads to amplification of the errors introduced when initializing the extension fields in the region around the zero level set.</li></ul>
<p>
<ul>
<li>The distance function computed when using a second-order spatial discretization are approximately second-order accurate in the L2 norm but are only first-order accurate in the L-infinity norm. The reason for this behavior is that the current implementation uses only a first-order accurate scheme for initializing the grid points around the zero-level set.</li></ul>
<p>
<ul>
<li>For grid points that are masked out, the distance function and extension fields are set to 0.</li></ul>
<p>
<ul>
<li>It is assumed that the user has allocated the memory for the distance function, extension fields, phi, and source fields.</li></ul>
<p>
<ul>
<li>It is assumed that the phi and mask data arrays are both of the same size. That is, all data fields are assumed to have the same index space extents.</li></ul>
<p>
<ul>
<li>If mask is set to a NULL pointer, then all grid points are treated as being in the interior of the domain.</li></ul>
<p>
<ul>
<li>The number of extension fields is assumed to be equal to the number of source fields. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="lsm_fast_marching_method.h::computeExtensionFields3d" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int computeExtensionFields3d </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LSMLIB_REAL *&nbsp;</td>
          <td class="mdname" nowrap> <em>distance_function</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>LSMLIB_REAL **&nbsp;</td>
          <td class="mdname" nowrap> <em>extension_fields</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>LSMLIB_REAL *&nbsp;</td>
          <td class="mdname" nowrap> <em>phi</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>LSMLIB_REAL *&nbsp;</td>
          <td class="mdname" nowrap> <em>mask</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>LSMLIB_REAL **&nbsp;</td>
          <td class="mdname" nowrap> <em>source_fields</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>num_extension_fields</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_discretization_order</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>grid_dims</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>LSMLIB_REAL *&nbsp;</td>
          <td class="mdname" nowrap> <em>dx</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
computeExtensionFields3d uses the FMM algorithm to compute the distance function and extension fields from the original level set function, phi, and the specified source fields.<p>
Arguments:<ul>
<li>distance_function (out): updated distance function</li><li>extension_fields (out): extension fields</li><li>phi (in): original level set function</li><li>mask (in): mask for domain of problem; grid points outside of the domain of the problem should be set to a negative value.</li><li>source_fields(in): source fields used to compute extension fields</li><li>num_extension_fields (in): number of extension fields to compute</li><li>spatial_discretization_order (in): order of finite differences used to compute spatial derivatives</li><li>grid_dims (in): array of index space extents for all fields</li><li>dx (in): array of grid cell sizes in each coordinate direction</li></ul>
<p>
Return value: error code (see NOTES for translation)<p>
NOTES:<ul>
<li>When the second-order spatial discretization is requested, only the distance function is computed using the second-order scheme. The extension fields are computed using a first-order discretization of the gradient for the extension field and a second-order accurate discretization of the gradient for the distance function. We use a first-order discretization when computing extension fields because the second-order discretization is "unstable" and leads to amplification of the errors introduced when initializing the extension fields in the region around the zero level set.</li></ul>
<p>
<ul>
<li>The distance function computed when using a second-order spatial discretization are approximately second-order accurate in the L2 norm but are only first-order accurate in the L-infinity norm. The reason for this behavior is that the current implementation uses only a first-order accurate scheme for initializing the grid points around the zero-level set.</li></ul>
<p>
<ul>
<li>For grid points that are masked out, the distance function and extension fields are set to 0.</li></ul>
<p>
<ul>
<li>It is assumed that the user has allocated the memory for the distance function, extension fields, phi, and source fields.</li></ul>
<p>
<ul>
<li>It is assumed that the phi and mask data arrays are both of the same size. That is, all data fields are assumed to have the same index space extents.</li></ul>
<p>
<ul>
<li>If mask is set to a NULL pointer, then all grid points are treated as being in the interior of the domain.</li></ul>
<p>
<ul>
<li>The number of extension fields is assumed to be equal to the number of source fields. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="lsm_fast_marching_method.h::solveEikonalEquation2d" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int solveEikonalEquation2d </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LSMLIB_REAL *&nbsp;</td>
          <td class="mdname" nowrap> <em>phi</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>LSMLIB_REAL *&nbsp;</td>
          <td class="mdname" nowrap> <em>speed</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>LSMLIB_REAL *&nbsp;</td>
          <td class="mdname" nowrap> <em>mask</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_discretization_order</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>grid_dims</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>LSMLIB_REAL *&nbsp;</td>
          <td class="mdname" nowrap> <em>dx</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
solveEikonalEquation2d uses the FMM algorithm to solve the Eikonal equation<p>
|grad(phi)| = 1/speed(x,y)<p>
in two space dimensions with the specified boundary data and speed function.<p>
This function assumes that the solution phi is assumed to be strictly non-negative with values in the interior of the domain greater than the values on the boundaries. For problems where phi takes on negative values with interior values greater than boundary values, this function can be used to solve for psi = phi + C, where C is a constant offset that ensures that psi is strictly non-negative. For problems where interior values are less than boundary values, this function can be used to solve for psi = -phi.<p>
Arguments:<ul>
<li>phi (in/out): pointer to solution to Eikonal equation phi must be initialized as specified in the NOTES below.</li><li>speed (in): pointer to speed field</li><li>mask (in): mask for domain of problem; grid points outside of the domain of the problem should be set to a negative value.</li><li>spatial_discretization_order (in): order of finite differences used to compute spatial derivatives</li><li>grid_dims (in): array of index space extents for all fields</li><li>dx (in): array of grid cell sizes in each coordinate direction</li></ul>
<p>
Return value: error code (see NOTES for translation)<p>
NOTES:<ul>
<li>When using the second-order spatial discretization, the solution phi is second-order accurate in the L-infinity norm only if the "boundary values" of phi are specified in a layer of grid cells at least two deep near the mathematical/physical domain boundary. Otherwise, the values of the solution near the boundary will only be first-order accurate. Close to second-order convergence in the L2 norm is achieved using the second-order scheme even if only one layer of boundary values is specified.</li></ul>
<p>
<ul>
<li>phi MUST be initialized so that the values for phi at grid points on or adjacent to the boundary of the domain for the Eikonal equation are correctly set. All other grid points should be set to have negative values for phi.</li></ul>
<p>
<ul>
<li>For grid points that are masked out or have speed equal to zero, phi is set to LSMLIB_REAL_MAX.</li></ul>
<p>
<ul>
<li>It is assumed that the phi, speed, and mask data arrays are all of the same size. That is, all data fields are assumed to have the same index space extents.</li></ul>
<p>
<ul>
<li>Both phi and the speed function MUST be strictly non-negative.</li></ul>
<p>
<ul>
<li>It is the user's responsibility to set the speed function.</li></ul>
<p>
<ul>
<li>If mask is set to a NULL pointer, then all grid points are treated as being in the interior of the domain. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="lsm_fast_marching_method.h::solveEikonalEquation3d" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int solveEikonalEquation3d </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LSMLIB_REAL *&nbsp;</td>
          <td class="mdname" nowrap> <em>phi</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>LSMLIB_REAL *&nbsp;</td>
          <td class="mdname" nowrap> <em>speed</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>LSMLIB_REAL *&nbsp;</td>
          <td class="mdname" nowrap> <em>mask</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>spatial_discretization_order</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>grid_dims</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>LSMLIB_REAL *&nbsp;</td>
          <td class="mdname" nowrap> <em>dx</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
solveEikonalEquation3d uses the FMM algorithm to solve the Eikonal equation<p>
|grad(phi)| = 1/speed(x,y,z)<p>
in three space dimensions with the specified boundary data and speed function.<p>
This function assumes that the solution phi is assumed to be strictly non-negative with values in the interior of the domain greater than the values on the boundaries. For problems where phi takes on negative values with interior values greater than boundary values, this function can be used to solve for psi = phi + C, where C is a constant offset that ensures that psi is strictly non-negative. For problems where interior values are less than boundary values, this function can be used to solve for psi = -phi.<p>
Arguments:<ul>
<li>phi (in/out): pointer to solution to Eikonal equation phi must be initialized as specified in the NOTES below.</li><li>speed (in): pointer to speed field</li><li>mask (in): mask for domain of problem; grid points outside of the domain of the problem should be set to a negative value.</li><li>spatial_discretization_order (in): order of finite differences used to compute spatial derivatives</li><li>grid_dims (in): array of index space extents for all fields</li><li>dx (in): array of grid cell sizes in each coordinate direction</li></ul>
<p>
Return value: error code (see NOTES for translation)<p>
NOTES:<ul>
<li>When using the second-order spatial discretization, the solution phi is second-order accurate in the L-infinity norm only if the "boundary values" of phi are specified in a layer of grid cells at least two deep near the mathematical/physical domain boundary. Otherwise, the values of the solution near the boundary will only be first-order accurate. Close to second-order convergence in the L2 norm is achieved using the second-order scheme even if only one layer of boundary values is specified.</li></ul>
<p>
<ul>
<li>phi MUST be initialized so that the values for phi at grid points on or adjacent to the boundary of the domain for the Eikonal equation are correctly set. All other grid points should be set to have negative values for phi.</li></ul>
<p>
<ul>
<li>For grid points that are masked out or have speed equal to zero, phi is set to LSMLIB_REAL_MAX.</li></ul>
<p>
<ul>
<li>It is assumed that the phi, speed, and mask data arrays are all of the same size. That is, all data fields are assumed to have the same index space extents.</li></ul>
<p>
<ul>
<li>Both phi and the speed function MUST be strictly non-negative.</li></ul>
<p>
<ul>
<li>It is the user's responsibility to set the speed function.</li></ul>
<p>
<ul>
<li>If mask is set to a NULL pointer, then all grid points are treated as being in the interior of the domain. </li></ul>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sun May 3 19:14:22 2009 for LSMLIB by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
