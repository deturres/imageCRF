<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LSMLIB: lsm_macros.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>lsm_macros.h</h1><a href="lsm__macros_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * File:        lsm_macros.h</span>
00003 <span class="comment"> * Copyrights:  (c) 2005 The Trustees of Princeton University and Board of</span>
00004 <span class="comment"> *                  Regents of the University of Texas.  All rights reserved.</span>
00005 <span class="comment"> *              (c) 2009 Kevin T. Chu.  All rights reserved.</span>
00006 <span class="comment"> * Revision:    $Revision: 149 $</span>
00007 <span class="comment"> * Modified:    $Date: 2009-01-18 00:31:09 -0800 (Sun, 18 Jan 2009) $</span>
00008 <span class="comment"> * Description: Header file with helpful macros for manipulating data arrays</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="preprocessor">#ifndef included_lsm_macros_h</span>
00012 <span class="preprocessor"></span><span class="preprocessor">#define included_lsm_macros_h</span>
00013 <span class="preprocessor"></span>
00014 <span class="preprocessor">#include &lt;float.h&gt;</span>
00015 <span class="preprocessor">#include "LSMLIB_config.h"</span>
00016 
00017 <span class="preprocessor">#ifdef __cplusplus</span>
00018 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00019 <span class="preprocessor">#endif</span>
00020 <span class="preprocessor"></span>
00021 
00030 <span class="preprocessor">#include &lt;float.h&gt;</span>
00031 <span class="preprocessor">#include "<a class="code" href="lsm__grid_8h.html">lsm_grid.h</a>"</span>
00032 
00033 
<a name="l00043"></a><a class="code" href="lsm__macros_8h.html#a0">00043</a> <span class="preprocessor">#define SET_DATA_TO_CONSTANT(data, grid, value)                            \</span>
00044 <span class="preprocessor">{                                                                          \</span>
00045 <span class="preprocessor">  int idx;                                                                 \</span>
00046 <span class="preprocessor">  for (idx = 0; idx &lt; grid-&gt;num_gridpts; idx++)                            \</span>
00047 <span class="preprocessor">  {                                                                        \</span>
00048 <span class="preprocessor">    data[idx] = value;                                                     \</span>
00049 <span class="preprocessor">  }                                                                        \</span>
00050 <span class="preprocessor">}</span>
00051 <span class="preprocessor"></span>
00052  
<a name="l00061"></a><a class="code" href="lsm__macros_8h.html#a1">00061</a> <span class="preprocessor">#define NEGATE_DATA(data, grid)                                            \</span>
00062 <span class="preprocessor">{                                                                          \</span>
00063 <span class="preprocessor">  int idx;                                                                 \</span>
00064 <span class="preprocessor">  for (idx = 0; idx &lt; grid-&gt;num_gridpts; idx++)                            \</span>
00065 <span class="preprocessor">  {                                                                        \</span>
00066 <span class="preprocessor">     data[idx] = -data[idx];                                               \</span>
00067 <span class="preprocessor">  }                                                                        \</span>
00068 <span class="preprocessor">}   </span>
00069 <span class="preprocessor"></span>
00070 
<a name="l00084"></a><a class="code" href="lsm__macros_8h.html#a2">00084</a> <span class="preprocessor">#define IMPOSE_MASK(phi_masked, mask, phi, grid)                           \</span>
00085 <span class="preprocessor">{                                                                          \</span>
00086 <span class="preprocessor">  int idx;                                                                 \</span>
00087 <span class="preprocessor">  for(idx = 0; idx &lt; grid-&gt;num_gridpts; idx++)                             \</span>
00088 <span class="preprocessor">  {                                                                        \</span>
00089 <span class="preprocessor">    phi_masked[idx] = (mask[idx] &gt; phi[idx]) ? mask[idx] : phi[idx];       \</span>
00090 <span class="preprocessor">  }                                                                        \</span>
00091 <span class="preprocessor">}</span>
00092 <span class="preprocessor"></span>
<a name="l00108"></a><a class="code" href="lsm__macros_8h.html#a3">00108</a> <span class="preprocessor">#define IMPOSE_MASK_LOCAL(phi_masked, mask, phi, grid, p)                    \</span>
00109 <span class="preprocessor">{                                                                            \</span>
00110 <span class="preprocessor">   int idx, l;                                                               \</span>
00111 <span class="preprocessor">                                                                             \</span>
00112 <span class="preprocessor">   if(grid-&gt;num_dims == 3)                                                   \</span>
00113 <span class="preprocessor">     for(l = (p-&gt;n_lo)[0]; l &lt; (p-&gt;n_hi)[0]; l++)                            \</span>
00114 <span class="preprocessor">     {                                                                       \</span>
00115 <span class="preprocessor">  idx = (p-&gt;index_x)[l] + (p-&gt;index_y)[l]*nx + (p-&gt;index_z)[l]*nxy;          \</span>
00116 <span class="preprocessor">        phi_masked[idx] = (mask[idx] &gt; phi[idx]) ? mask[idx] : phi[idx];     \</span>
00117 <span class="preprocessor">     }                                                                       \</span>
00118 <span class="preprocessor">   else                                                                      \</span>
00119 <span class="preprocessor">     for(l = (p-&gt;n_lo)[0]; l &lt; (p-&gt;n_hi)[0]; l++)                            \</span>
00120 <span class="preprocessor">     {                                                                       \</span>
00121 <span class="preprocessor">  idx = (p-&gt;index_x)[l] + (p-&gt;index_y)[l]*nx;                                \</span>
00122 <span class="preprocessor">        phi_masked[idx] = (mask[idx] &gt; phi[idx]) ? mask[idx] : phi[idx];     \</span>
00123 <span class="preprocessor">     }                                                                       \</span>
00124 <span class="preprocessor">}</span>
00125 <span class="preprocessor"></span>
00126  
00127  <span class="comment">/* IMPOSE_MIN(phi_min, phi1, phi2, grid) computes minimum of two (level set)</span>
00128 <span class="comment"> * functions. Note that the set described by (phi_min &lt; 0) is union of</span>
00129 <span class="comment"> * (phi1 &lt; 0) and (phi2 &lt; 0)</span>
00130 <span class="comment"> *</span>
00131 <span class="comment"> * Arguments:</span>
00132 <span class="comment"> *  - phi_min(out):  output array, phi_min = min(phi1,phi2)</span>
00133 <span class="comment"> *  - phi1 (in):     array containing </span>
00134 <span class="comment"> *  - phi2 (in):     array containing</span>
00135 <span class="comment"> *  - grid (in):     pointer to Grid</span>
00136 <span class="comment">*/</span>  
<a name="l00137"></a><a class="code" href="lsm__macros_8h.html#a4">00137</a> <span class="preprocessor">#define IMPOSE_MIN(phi_min, phi1, phi2, grid)                            \</span>
00138 <span class="preprocessor">{                                                                        \</span>
00139 <span class="preprocessor">  int idx;                                                               \</span>
00140 <span class="preprocessor">  for(idx = 0; idx &lt; grid-&gt;num_gridpts; idx++)                           \</span>
00141 <span class="preprocessor">  {                                                                      \</span>
00142 <span class="preprocessor">    phi_min[idx] = (phi1[idx] &lt; phi2[idx]) ? phi1[idx] : phi2[idx];      \</span>
00143 <span class="preprocessor">  }                                                                      \</span>
00144 <span class="preprocessor">}</span>
00145 <span class="preprocessor"></span>
<a name="l00155"></a><a class="code" href="lsm__macros_8h.html#a5">00155</a> <span class="preprocessor">#define COPY_DATA(data_dst, data_src, grid)                                \</span>
00156 <span class="preprocessor">{                                                                          \</span>
00157 <span class="preprocessor">  int idx;                                                                 \</span>
00158 <span class="preprocessor">  for(idx = 0; idx &lt; grid-&gt;num_gridpts; idx++)                             \</span>
00159 <span class="preprocessor">  {                                                                        \</span>
00160 <span class="preprocessor">    data_dst[idx] = data_src[idx];                                         \</span>
00161 <span class="preprocessor">  }                                                                        \</span>
00162 <span class="preprocessor">}</span>
00163 <span class="preprocessor"></span>
00164 
<a name="l00176"></a><a class="code" href="lsm__macros_8h.html#a6">00176</a> <span class="preprocessor">#define COMPUTE_MAX_ABS_ERR(max_abs_err, data1, data2, grid)               \</span>
00177 <span class="preprocessor">{                                                                          \</span>
00178 <span class="preprocessor">  int idx;                                                                 \</span>
00179 <span class="preprocessor">  LSMLIB_REAL min_err, max_err, err1, err2, err;                           \</span>
00180 <span class="preprocessor">  min_err = FLT_MAX; max_err = 0.0;                                        \</span>
00181 <span class="preprocessor">  for(idx = 0; idx &lt; grid-&gt;num_gridpts; idx++)                             \</span>
00182 <span class="preprocessor">  {                                                                        \</span>
00183 <span class="preprocessor">    err = data1[idx] - data2[idx];                                         \</span>
00184 <span class="preprocessor">      if(err &lt; min_err) min_err = err;                                     \</span>
00185 <span class="preprocessor">      if(err &gt; max_err) max_err = err;                                     \</span>
00186 <span class="preprocessor">   }                                                                       \</span>
00187 <span class="preprocessor">   err1 = fabs(min_err); err2 = fabs(max_err);                             \</span>
00188 <span class="preprocessor">   max_abs_err = ( err1 &gt; err2 ) ? err1 : err2;                            \</span>
00189 <span class="preprocessor">}   </span>
00190 <span class="preprocessor"></span> 
00191 
<a name="l00202"></a><a class="code" href="lsm__macros_8h.html#a7">00202</a> <span class="preprocessor">#define COMPUTE_MAX_ABS_DATA(max_abs, data, grid)                          \</span>
00203 <span class="preprocessor">{                                                                          \</span>
00204 <span class="preprocessor">  int idx;                                                                 \</span>
00205 <span class="preprocessor">  LSMLIB_REAL min_err, max_err, err1, err2, err;                           \</span>
00206 <span class="preprocessor">  min_err = FLT_MAX; max_err = 0.0;                                        \</span>
00207 <span class="preprocessor">  for(idx = 0; idx &lt; grid-&gt;num_gridpts; idx++)                             \</span>
00208 <span class="preprocessor">  {                                                                        \</span>
00209 <span class="preprocessor">    err = data[idx];                                                       \</span>
00210 <span class="preprocessor">    if(err &lt; min_err) min_err = err;                                       \</span>
00211 <span class="preprocessor">    if(err &gt; max_err) max_err = err;                                       \</span>
00212 <span class="preprocessor">  }                                                                        \</span>
00213 <span class="preprocessor">  err1 = fabs(min_err); err2 = fabs(max_err);                              \</span>
00214 <span class="preprocessor">  max_abs = ( err1 &gt; err2 ) ? err1 : err2;                                 \</span>
00215 <span class="preprocessor">}</span>
00216 <span class="preprocessor"></span>
00217 
<a name="l00228"></a><a class="code" href="lsm__macros_8h.html#a8">00228</a> <span class="preprocessor">#define EXAMINE_ARRAY(name,data,g)                                         \</span>
00229 <span class="preprocessor">{                                                                          \</span>
00230 <span class="preprocessor">  int idx;                                                                 \</span>
00231 <span class="preprocessor">  LSMLIB_REAL min = FLT_MAX, max = -FLT_MAX;                               \</span>
00232 <span class="preprocessor">  LSMLIB_REAL abs_min = FLT_MAX, abs_val;                                  \</span>
00233 <span class="preprocessor">  for(idx=0; idx &lt; g-&gt;num_gridpts; idx++)                                  \</span>
00234 <span class="preprocessor">  {                                                                        \</span>
00235 <span class="preprocessor">    if (isnan(data[idx])) printf("\nNaN at position %d",idx);              \</span>
00236 <span class="preprocessor">    if (isinf(data[idx])) printf("\ninf at position %d",idx);              \</span>
00237 <span class="preprocessor">    if( data[idx] &lt; min) min = data[idx];                                  \</span>
00238 <span class="preprocessor">    if( data[idx] &gt; max) max = data[idx];                                  \</span>
00239 <span class="preprocessor">    abs_val = fabs(data[idx]);                                             \</span>
00240 <span class="preprocessor">    if( abs_val &lt; abs_min &amp;&amp; abs_val &gt; DBL_EPSILON) abs_min = abs_val;     \</span>
00241 <span class="preprocessor">  }                                                                        \</span>
00242 <span class="preprocessor">  printf("\n%s min %g max %g min(|array|) %g",name,min,max,abs_min);       \</span>
00243 <span class="preprocessor">  fflush(stdout);                                                          \</span>
00244 <span class="preprocessor">}</span>
00245 <span class="preprocessor"></span>
00246 
<a name="l00256"></a><a class="code" href="lsm__macros_8h.html#a9">00256</a> <span class="preprocessor">#define PRINT_ARRAY_2D(data, grid)                                         \</span>
00257 <span class="preprocessor">{                                                                          \</span>
00258 <span class="preprocessor">  int i,j;                                                                 \</span>
00259 <span class="preprocessor">  for(j = grid-&gt;jhi_gb; j &gt;= grid-&gt;jlo_gb; j--)                            \</span>
00260 <span class="preprocessor">  {                                                                        \</span>
00261 <span class="preprocessor">    for(i = grid-&gt;ilo_gb; i &lt;= grid-&gt;ihi_gb; i++)                          \</span>
00262 <span class="preprocessor">    {                                                                      \</span>
00263 <span class="preprocessor">      idx = i + j*(grid-&gt;grid_dims)[0];                                    \</span>
00264 <span class="preprocessor">      printf("%g ", data[idx]);                                            \</span>
00265 <span class="preprocessor">    }                                                                      \</span>
00266 <span class="preprocessor">    printf("\n");                                                          \</span>
00267 <span class="preprocessor">  }                                                                        \</span>
00268 <span class="preprocessor">}</span>
00269 <span class="preprocessor"></span>
00270 
00271 
00272 
00273 <span class="preprocessor">#ifdef __cplusplus</span>
00274 <span class="preprocessor"></span>}
00275 <span class="preprocessor">#endif</span>
00276 <span class="preprocessor"></span>
00277 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun May 3 19:14:21 2009 for LSMLIB by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
